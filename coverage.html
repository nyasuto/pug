
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>interp: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/nyasuto/pug/cmd/interp/main.go (0.0%)</option>
				
				<option value="file1">github.com/nyasuto/pug/cmd/pug/main.go (0.0%)</option>
				
				<option value="file2">github.com/nyasuto/pug/main.go (0.0%)</option>
				
				<option value="file3">github.com/nyasuto/pug/phase1/ast.go (46.6%)</option>
				
				<option value="file4">github.com/nyasuto/pug/phase1/builtins.go (20.0%)</option>
				
				<option value="file5">github.com/nyasuto/pug/phase1/environment.go (100.0%)</option>
				
				<option value="file6">github.com/nyasuto/pug/phase1/evaluator.go (89.0%)</option>
				
				<option value="file7">github.com/nyasuto/pug/phase1/lexer.go (91.4%)</option>
				
				<option value="file8">github.com/nyasuto/pug/phase1/object.go (16.4%)</option>
				
				<option value="file9">github.com/nyasuto/pug/phase1/parser.go (85.0%)</option>
				
				<option value="file10">github.com/nyasuto/pug/phase1/repl.go (0.0%)</option>
				
				<option value="file11">github.com/nyasuto/pug/phase1/token.go (75.0%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">no coverage</span>
				<span class="cov1">low coverage</span>
				<span class="cov2">*</span>
				<span class="cov3">*</span>
				<span class="cov4">*</span>
				<span class="cov5">*</span>
				<span class="cov6">*</span>
				<span class="cov7">*</span>
				<span class="cov8">*</span>
				<span class="cov9">*</span>
				<span class="cov10">high coverage</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "fmt"
        "os"
)

func main() <span class="cov0" title="0">{
        fmt.Println("ğŸ¶ pug ã‚³ãƒ³ãƒ‘ã‚¤ãƒ© - Phase 1 ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ—ãƒªã‚¿ãƒ¼")
        fmt.Println("æ®µéšçš„ã«å­¦ã¶ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©å®Ÿè£…ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ")

        if len(os.Args) &gt; 1 </span><span class="cov0" title="0">{
                filename := os.Args[1]
                fmt.Printf("ğŸ“„ ãƒ•ã‚¡ã‚¤ãƒ« '%s' ã‚’å‡¦ç†ä¸­...\n", filename)
                fmt.Println("âš ï¸  ã¾ã å®Ÿè£…ã•ã‚Œã¦ã„ã¾ã›ã‚“ - Phase 1.0 ãƒ¬ã‚¯ã‚µãƒ¼ã‹ã‚‰é–‹å§‹ã—ã¦ãã ã•ã„")
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("ğŸ“ ä½¿ç”¨æ–¹æ³•: interp &lt;filename.dog&gt;")
                fmt.Println("ğŸ”„ ã¾ãŸã¯ REPL ãƒ¢ãƒ¼ãƒ‰: interp --repl")
        }</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "fmt"
        "os"
)

func main() <span class="cov0" title="0">{
        fmt.Println("ğŸ¶ pug ã‚³ãƒ³ãƒ‘ã‚¤ãƒ© - Phase 2 ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©")
        fmt.Println("æ®µéšçš„ã«å­¦ã¶ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©å®Ÿè£…ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ")

        if len(os.Args) &gt; 1 </span><span class="cov0" title="0">{
                filename := os.Args[1]
                fmt.Printf("ğŸ“„ ãƒ•ã‚¡ã‚¤ãƒ« '%s' ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ«ä¸­...\n", filename)
                fmt.Println("âš ï¸  ã¾ã å®Ÿè£…ã•ã‚Œã¦ã„ã¾ã›ã‚“ - Phase 2.0 ã‚³ãƒ¼ãƒ‰ç”Ÿæˆå™¨ã‹ã‚‰é–‹å§‹ã—ã¦ãã ã•ã„")
        }</span> else<span class="cov0" title="0"> {
                fmt.Println("ğŸ“ ä½¿ç”¨æ–¹æ³•: pug &lt;filename.dog&gt; [-o output]")
                fmt.Println("ğŸ”§ ã‚ªãƒ—ã‚·ãƒ§ãƒ³:")
                fmt.Println("  --emit-asm    ã‚¢ã‚»ãƒ³ãƒ–ãƒªã‚³ãƒ¼ãƒ‰ã‚’è¡¨ç¤º")
                fmt.Println("  --emit-ast    ASTæ§‹é€ ã‚’è¡¨ç¤º")
                fmt.Println("  -O0,-O1,-O2   æœ€é©åŒ–ãƒ¬ãƒ™ãƒ«")
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "fmt"
        "os"
        "os/user"

        "github.com/nyasuto/pug/phase1"
)

func main() <span class="cov0" title="0">{
        user, err := user.Current()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">fmt.Printf("Hello %s! This is the Dog programming language!\n",
                user.Username)
        fmt.Printf("Feel free to type in commands\n")
        phase1.Start(os.Stdin, os.Stdout)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package phase1

import (
        "bytes"
        "strings"
)

// Node ã¯å…¨ã¦ã®ASTãƒãƒ¼ãƒ‰ãŒå®Ÿè£…ã™ã‚‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
type Node interface {
        TokenLiteral() string
        String() string
}

// Statement ã¯æ–‡ã‚’è¡¨ã™ãƒãƒ¼ãƒ‰
type Statement interface {
        Node
        statementNode()
}

// Expression ã¯å¼ã‚’è¡¨ã™ãƒãƒ¼ãƒ‰
type Expression interface {
        Node
        expressionNode()
}

// Program ã¯ASTã®ãƒ«ãƒ¼ãƒˆãƒãƒ¼ãƒ‰
type Program struct {
        Statements []Statement
}

func (p *Program) TokenLiteral() string <span class="cov0" title="0">{
        if len(p.Statements) &gt; 0 </span><span class="cov0" title="0">{
                return p.Statements[0].TokenLiteral()
        }</span>
        <span class="cov0" title="0">return ""</span>
}

func (p *Program) String() string <span class="cov8" title="25">{
        var out bytes.Buffer
        for _, s := range p.Statements </span><span class="cov8" title="26">{
                out.WriteString(s.String())
        }</span>
        <span class="cov8" title="25">return out.String()</span>
}

// LetStatement ã¯letæ–‡ã‚’è¡¨ã™ãƒãƒ¼ãƒ‰
type LetStatement struct {
        Token Token // LETãƒˆãƒ¼ã‚¯ãƒ³
        Name  *Identifier
        Value Expression
}

func (ls *LetStatement) statementNode()       {<span class="cov0" title="0">}</span>
func (ls *LetStatement) TokenLiteral() string <span class="cov4" title="5">{ return ls.Token.Literal }</span>
func (ls *LetStatement) String() string <span class="cov0" title="0">{
        var out bytes.Buffer
        out.WriteString(ls.TokenLiteral() + " ")
        out.WriteString(ls.Name.String())
        out.WriteString(" = ")
        if ls.Value != nil </span><span class="cov0" title="0">{
                out.WriteString(ls.Value.String())
        }</span>
        <span class="cov0" title="0">out.WriteString(";")
        return out.String()</span>
}

// ReturnStatement ã¯returnæ–‡ã‚’è¡¨ã™ãƒãƒ¼ãƒ‰
type ReturnStatement struct {
        Token       Token // RETURNãƒˆãƒ¼ã‚¯ãƒ³
        ReturnValue Expression
}

func (rs *ReturnStatement) statementNode()       {<span class="cov0" title="0">}</span>
func (rs *ReturnStatement) TokenLiteral() string <span class="cov1" title="1">{ return rs.Token.Literal }</span>
func (rs *ReturnStatement) String() string <span class="cov0" title="0">{
        var out bytes.Buffer
        out.WriteString(rs.TokenLiteral() + " ")
        if rs.ReturnValue != nil </span><span class="cov0" title="0">{
                out.WriteString(rs.ReturnValue.String())
        }</span>
        <span class="cov0" title="0">out.WriteString(";")
        return out.String()</span>
}

// ExpressionStatement ã¯å¼æ–‡ã‚’è¡¨ã™ãƒãƒ¼ãƒ‰
type ExpressionStatement struct {
        Token      Token // å¼ã®æœ€åˆã®ãƒˆãƒ¼ã‚¯ãƒ³
        Expression Expression
}

func (es *ExpressionStatement) statementNode()       {<span class="cov0" title="0">}</span>
func (es *ExpressionStatement) TokenLiteral() string <span class="cov0" title="0">{ return es.Token.Literal }</span>
func (es *ExpressionStatement) String() string <span class="cov8" title="27">{
        if es.Expression != nil </span><span class="cov8" title="27">{
                return es.Expression.String()
        }</span>
        <span class="cov0" title="0">return ""</span>
}

// Identifier ã¯è­˜åˆ¥å­ã‚’è¡¨ã™ãƒãƒ¼ãƒ‰
type Identifier struct {
        Token Token // IDENTãƒˆãƒ¼ã‚¯ãƒ³
        Value string
}

func (i *Identifier) expressionNode()      {<span class="cov0" title="0">}</span>
func (i *Identifier) TokenLiteral() string <span class="cov9" title="41">{ return i.Token.Literal }</span>
func (i *Identifier) String() string       <span class="cov9" title="42">{ return i.Value }</span>

// IntegerLiteral ã¯æ•´æ•°ãƒªãƒ†ãƒ©ãƒ«ã‚’è¡¨ã™ãƒãƒ¼ãƒ‰
type IntegerLiteral struct {
        Token Token // INTãƒˆãƒ¼ã‚¯ãƒ³
        Value int64
}

func (il *IntegerLiteral) expressionNode()      {<span class="cov0" title="0">}</span>
func (il *IntegerLiteral) TokenLiteral() string <span class="cov8" title="29">{ return il.Token.Literal }</span>
func (il *IntegerLiteral) String() string       <span class="cov9" title="49">{ return il.Token.Literal }</span>

// FloatLiteral ã¯æµ®å‹•å°æ•°ç‚¹ãƒªãƒ†ãƒ©ãƒ«ã‚’è¡¨ã™ãƒãƒ¼ãƒ‰
type FloatLiteral struct {
        Token Token // FLOATãƒˆãƒ¼ã‚¯ãƒ³
        Value float64
}

func (fl *FloatLiteral) expressionNode()      {<span class="cov0" title="0">}</span>
func (fl *FloatLiteral) TokenLiteral() string <span class="cov6" title="11">{ return fl.Token.Literal }</span>
func (fl *FloatLiteral) String() string       <span class="cov0" title="0">{ return fl.Token.Literal }</span>

// StringLiteral ã¯æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã‚’è¡¨ã™ãƒãƒ¼ãƒ‰
type StringLiteral struct {
        Token Token // STRINGãƒˆãƒ¼ã‚¯ãƒ³
        Value string
}

func (sl *StringLiteral) expressionNode()      {<span class="cov0" title="0">}</span>
func (sl *StringLiteral) TokenLiteral() string <span class="cov0" title="0">{ return sl.Token.Literal }</span>
func (sl *StringLiteral) String() string       <span class="cov0" title="0">{ return "\"" + sl.Value + "\"" }</span>

// Boolean ã¯ãƒ–ãƒ¼ãƒ«å€¤ãƒªãƒ†ãƒ©ãƒ«ã‚’è¡¨ã™ãƒãƒ¼ãƒ‰
type Boolean struct {
        Token Token // TRUE | FALSEãƒˆãƒ¼ã‚¯ãƒ³
        Value bool
}

func (b *Boolean) expressionNode()      {<span class="cov0" title="0">}</span>
func (b *Boolean) TokenLiteral() string <span class="cov5" title="9">{ return b.Token.Literal }</span>
func (b *Boolean) String() string       <span class="cov4" title="6">{ return b.Token.Literal }</span>

// PrefixExpression ã¯å‰ç½®æ¼”ç®—å­å¼ã‚’è¡¨ã™ãƒãƒ¼ãƒ‰
type PrefixExpression struct {
        Token    Token // å‰ç½®æ¼”ç®—å­ãƒˆãƒ¼ã‚¯ãƒ³ï¼ˆ!ã€-ãªã©ï¼‰
        Operator string
        Right    Expression
}

func (pe *PrefixExpression) expressionNode()      {<span class="cov0" title="0">}</span>
func (pe *PrefixExpression) TokenLiteral() string <span class="cov0" title="0">{ return pe.Token.Literal }</span>
func (pe *PrefixExpression) String() string <span class="cov4" title="6">{
        var out bytes.Buffer
        out.WriteString("(")
        out.WriteString(pe.Operator)
        out.WriteString(pe.Right.String())
        out.WriteString(")")
        return out.String()
}</span>

// InfixExpression ã¯ä¸­ç½®æ¼”ç®—å­å¼ã‚’è¡¨ã™ãƒãƒ¼ãƒ‰
type InfixExpression struct {
        Token    Token // æ¼”ç®—å­ãƒˆãƒ¼ã‚¯ãƒ³
        Left     Expression
        Operator string
        Right    Expression
}

func (oe *InfixExpression) expressionNode()      {<span class="cov0" title="0">}</span>
func (oe *InfixExpression) TokenLiteral() string <span class="cov0" title="0">{ return oe.Token.Literal }</span>
func (oe *InfixExpression) String() string <span class="cov10" title="59">{
        var out bytes.Buffer
        out.WriteString("(")
        out.WriteString(oe.Left.String())
        out.WriteString(" " + oe.Operator + " ")
        out.WriteString(oe.Right.String())
        out.WriteString(")")
        return out.String()
}</span>

// IfExpression ã¯ifå¼ã‚’è¡¨ã™ãƒãƒ¼ãƒ‰
type IfExpression struct {
        Token       Token // IFãƒˆãƒ¼ã‚¯ãƒ³
        Condition   Expression
        Consequence *BlockStatement
        Alternative *BlockStatement
}

func (ie *IfExpression) expressionNode()      {<span class="cov0" title="0">}</span>
func (ie *IfExpression) TokenLiteral() string <span class="cov0" title="0">{ return ie.Token.Literal }</span>
func (ie *IfExpression) String() string <span class="cov0" title="0">{
        var out bytes.Buffer
        out.WriteString("if")
        out.WriteString(ie.Condition.String())
        out.WriteString(" ")
        out.WriteString(ie.Consequence.String())
        if ie.Alternative != nil </span><span class="cov0" title="0">{
                out.WriteString("else ")
                out.WriteString(ie.Alternative.String())
        }</span>
        <span class="cov0" title="0">return out.String()</span>
}

// BlockStatement ã¯ãƒ–ãƒ­ãƒƒã‚¯æ–‡ã‚’è¡¨ã™ãƒãƒ¼ãƒ‰
type BlockStatement struct {
        Token      Token // LBRACEãƒˆãƒ¼ã‚¯ãƒ³
        Statements []Statement
}

func (bs *BlockStatement) statementNode()       {<span class="cov0" title="0">}</span>
func (bs *BlockStatement) TokenLiteral() string <span class="cov0" title="0">{ return bs.Token.Literal }</span>
func (bs *BlockStatement) String() string <span class="cov1" title="1">{
        var out bytes.Buffer
        for _, s := range bs.Statements </span><span class="cov1" title="1">{
                out.WriteString(s.String())
        }</span>
        <span class="cov1" title="1">return out.String()</span>
}

// FunctionLiteral ã¯é–¢æ•°ãƒªãƒ†ãƒ©ãƒ«ã‚’è¡¨ã™ãƒãƒ¼ãƒ‰
type FunctionLiteral struct {
        Token      Token // FNãƒˆãƒ¼ã‚¯ãƒ³
        Parameters []*Identifier
        Body       *BlockStatement
}

func (fl *FunctionLiteral) expressionNode()      {<span class="cov0" title="0">}</span>
func (fl *FunctionLiteral) TokenLiteral() string <span class="cov0" title="0">{ return fl.Token.Literal }</span>
func (fl *FunctionLiteral) String() string <span class="cov0" title="0">{
        var out bytes.Buffer
        params := []string{}
        for _, p := range fl.Parameters </span><span class="cov0" title="0">{
                params = append(params, p.String())
        }</span>
        <span class="cov0" title="0">out.WriteString(fl.TokenLiteral())
        out.WriteString("(")
        out.WriteString(strings.Join(params, ", "))
        out.WriteString(") ")
        out.WriteString(fl.Body.String())
        return out.String()</span>
}

// CallExpression ã¯é–¢æ•°å‘¼ã³å‡ºã—å¼ã‚’è¡¨ã™ãƒãƒ¼ãƒ‰
type CallExpression struct {
        Token     Token // LPARENãƒˆãƒ¼ã‚¯ãƒ³
        Function  Expression
        Arguments []Expression
}

func (ce *CallExpression) expressionNode()      {<span class="cov0" title="0">}</span>
func (ce *CallExpression) TokenLiteral() string <span class="cov0" title="0">{ return ce.Token.Literal }</span>
func (ce *CallExpression) String() string <span class="cov4" title="4">{
        var out bytes.Buffer
        args := []string{}
        for _, a := range ce.Arguments </span><span class="cov6" title="10">{
                args = append(args, a.String())
        }</span>
        <span class="cov4" title="4">out.WriteString(ce.Function.String())
        out.WriteString("(")
        out.WriteString(strings.Join(args, ", "))
        out.WriteString(")")
        return out.String()</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package phase1

import "fmt"

// builtins ã¯çµ„ã¿è¾¼ã¿é–¢æ•°ã®ãƒãƒƒãƒ—
var builtins = map[string]*Builtin{
        "len": &amp;Builtin{
                Fn: func(args ...Object) Object <span class="cov10" title="5">{
                        if len(args) != 1 </span><span class="cov1" title="1">{
                                return newError("wrong number of arguments. got=%d, want=1",
                                        len(args))
                        }</span>

                        <span class="cov8" title="4">switch arg := args[0].(type) </span>{
                        case *Array:<span class="cov0" title="0">
                                return &amp;Integer{Value: int64(len(arg.Elements))}</span>
                        case *String:<span class="cov7" title="3">
                                return &amp;Integer{Value: int64(len(arg.Value))}</span>
                        default:<span class="cov1" title="1">
                                return newError("argument to `len` not supported, got %s",
                                        args[0].Type())</span>
                        }
                },
        },

        "first": &amp;Builtin{
                Fn: func(args ...Object) Object <span class="cov0" title="0">{
                        if len(args) != 1 </span><span class="cov0" title="0">{
                                return newError("wrong number of arguments. got=%d, want=1",
                                        len(args))
                        }</span>
                        <span class="cov0" title="0">if args[0].Type() != ARRAY_OBJ </span><span class="cov0" title="0">{
                                return newError("argument to `first` must be ARRAY, got %T",
                                        args[0])
                        }</span>

                        <span class="cov0" title="0">arr := args[0].(*Array)
                        if len(arr.Elements) &gt; 0 </span><span class="cov0" title="0">{
                                return arr.Elements[0]
                        }</span>

                        <span class="cov0" title="0">return NULL_OBJ_INSTANCE</span>
                },
        },

        "last": &amp;Builtin{
                Fn: func(args ...Object) Object <span class="cov0" title="0">{
                        if len(args) != 1 </span><span class="cov0" title="0">{
                                return newError("wrong number of arguments. got=%d, want=1",
                                        len(args))
                        }</span>
                        <span class="cov0" title="0">if args[0].Type() != ARRAY_OBJ </span><span class="cov0" title="0">{
                                return newError("argument to `last` must be ARRAY, got %T",
                                        args[0])
                        }</span>

                        <span class="cov0" title="0">arr := args[0].(*Array)
                        length := len(arr.Elements)
                        if length &gt; 0 </span><span class="cov0" title="0">{
                                return arr.Elements[length-1]
                        }</span>

                        <span class="cov0" title="0">return NULL_OBJ_INSTANCE</span>
                },
        },

        "rest": &amp;Builtin{
                Fn: func(args ...Object) Object <span class="cov0" title="0">{
                        if len(args) != 1 </span><span class="cov0" title="0">{
                                return newError("wrong number of arguments. got=%d, want=1",
                                        len(args))
                        }</span>
                        <span class="cov0" title="0">if args[0].Type() != ARRAY_OBJ </span><span class="cov0" title="0">{
                                return newError("argument to `rest` must be ARRAY, got %T",
                                        args[0])
                        }</span>

                        <span class="cov0" title="0">arr := args[0].(*Array)
                        length := len(arr.Elements)
                        if length &gt; 0 </span><span class="cov0" title="0">{
                                newElements := make([]Object, length-1)
                                copy(newElements, arr.Elements[1:length])
                                return &amp;Array{Elements: newElements}
                        }</span>

                        <span class="cov0" title="0">return NULL_OBJ_INSTANCE</span>
                },
        },

        "push": &amp;Builtin{
                Fn: func(args ...Object) Object <span class="cov0" title="0">{
                        if len(args) != 2 </span><span class="cov0" title="0">{
                                return newError("wrong number of arguments. got=%d, want=2",
                                        len(args))
                        }</span>
                        <span class="cov0" title="0">if args[0].Type() != ARRAY_OBJ </span><span class="cov0" title="0">{
                                return newError("argument to `push` must be ARRAY, got %T",
                                        args[0])
                        }</span>

                        <span class="cov0" title="0">arr := args[0].(*Array)
                        length := len(arr.Elements)

                        newElements := make([]Object, length+1)
                        copy(newElements, arr.Elements)
                        newElements[length] = args[1]

                        return &amp;Array{Elements: newElements}</span>
                },
        },

        "puts": &amp;Builtin{
                Fn: func(args ...Object) Object <span class="cov1" title="1">{
                        for _, arg := range args </span><span class="cov4" title="2">{
                                fmt.Println(arg.Inspect())
                        }</span>

                        <span class="cov1" title="1">return NULL_OBJ_INSTANCE</span>
                },
        },

        "type": &amp;Builtin{
                Fn: func(args ...Object) Object <span class="cov8" title="4">{
                        if len(args) != 1 </span><span class="cov0" title="0">{
                                return newError("wrong number of arguments. got=%d, want=1",
                                        len(args))
                        }</span>

                        <span class="cov8" title="4">return &amp;String{Value: string(args[0].Type())}</span>
                },
        },
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package phase1

// Environment ã¯å¤‰æ•°ã®æŸç¸›ã‚’ç®¡ç†ã™ã‚‹ç’°å¢ƒ
type Environment struct {
        store map[string]Object
        outer *Environment
}

// NewEnvironment ã¯æ–°ã—ã„ç’°å¢ƒã‚’ä½œæˆã™ã‚‹
func NewEnvironment() *Environment <span class="cov10" title="123">{
        s := make(map[string]Object)
        return &amp;Environment{store: s, outer: nil}
}</span>

// NewEnclosedEnvironment ã¯å¤–å´ã®ç’°å¢ƒã‚’æŒã¤æ–°ã—ã„ç’°å¢ƒã‚’ä½œæˆã™ã‚‹
func NewEnclosedEnvironment(outer *Environment) *Environment <span class="cov5" title="9">{
        env := NewEnvironment()
        env.outer = outer
        return env
}</span>

// Get ã¯å¤‰æ•°ã®å€¤ã‚’å–å¾—ã™ã‚‹
func (e *Environment) Get(name string) (Object, bool) <span class="cov7" title="40">{
        value, ok := e.store[name]
        if !ok &amp;&amp; e.outer != nil </span><span class="cov1" title="1">{
                value, ok = e.outer.Get(name)
        }</span>
        <span class="cov7" title="40">return value, ok</span>
}

// Set ã¯å¤‰æ•°ã«å€¤ã‚’è¨­å®šã™ã‚‹
func (e *Environment) Set(name string, val Object) Object <span class="cov7" title="26">{
        e.store[name] = val
        return val
}</span>
</pre>
		
		<pre class="file" id="file6" style="display: none">package phase1

import "fmt"

// Eval ã¯ASTãƒãƒ¼ãƒ‰ã‚’è©•ä¾¡ã—ã¦ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’è¿”ã™
func Eval(node Node, env *Environment) Object <span class="cov10" title="718">{
        switch node := node.(type) </span>{

        // Program
        case *Program:<span class="cov7" title="114">
                return evalProgram(node.Statements, env)</span>

        // Statements
        case *ExpressionStatement:<span class="cov7" title="128">
                return Eval(node.Expression, env)</span>

        case *LetStatement:<span class="cov4" title="14">
                val := Eval(node.Value, env)
                if isError(val) </span><span class="cov0" title="0">{
                        return val
                }</span>
                <span class="cov4" title="14">env.Set(node.Name.Value, val)
                return val</span>

        case *ReturnStatement:<span class="cov3" title="7">
                val := Eval(node.ReturnValue, env)
                if isError(val) </span><span class="cov1" title="1">{
                        return val
                }</span>
                <span class="cov3" title="6">return &amp;ReturnValue{Value: val}</span>

        case *BlockStatement:<span class="cov5" title="19">
                return evalBlockStatement(node, env)</span>

        // Expressions
        case *IntegerLiteral:<span class="cov7" title="152">
                return &amp;Integer{Value: node.Value}</span>

        case *FloatLiteral:<span class="cov5" title="31">
                return &amp;Float{Value: node.Value}</span>

        case *StringLiteral:<span class="cov4" title="14">
                return &amp;String{Value: node.Value}</span>

        case *Boolean:<span class="cov5" title="34">
                return nativeBoolToPugBoolean(node.Value)</span>

        case *PrefixExpression:<span class="cov5" title="20">
                right := Eval(node.Right, env)
                if isError(right) </span><span class="cov0" title="0">{
                        return right
                }</span>
                <span class="cov5" title="20">return evalPrefixExpression(node.Operator, right)</span>

        case *InfixExpression:<span class="cov7" title="106">
                left := Eval(node.Left, env)
                if isError(left) </span><span class="cov0" title="0">{
                        return left
                }</span>
                <span class="cov7" title="106">right := Eval(node.Right, env)
                if isError(right) </span><span class="cov0" title="0">{
                        return right
                }</span>
                <span class="cov7" title="106">return evalInfixExpression(node.Operator, left, right)</span>

        case *IfExpression:<span class="cov4" title="12">
                return evalIfExpression(node, env)</span>

        case *Identifier:<span class="cov6" title="39">
                return evalIdentifier(node, env)</span>

        case *FunctionLiteral:<span class="cov4" title="9">
                params := node.Parameters
                body := node.Body
                return &amp;Function{Parameters: params, Env: env, Body: body}</span>

        case *CallExpression:<span class="cov5" title="19">
                function := Eval(node.Function, env)
                if isError(function) </span><span class="cov0" title="0">{
                        return function
                }</span>
                <span class="cov5" title="19">args := evalExpressions(node.Arguments, env)
                if len(args) == 1 &amp;&amp; isError(args[0]) </span><span class="cov0" title="0">{
                        return args[0]
                }</span>
                <span class="cov5" title="19">return applyFunction(function, args)</span>

        default:<span class="cov0" title="0">
                return newError("unknown node type: %T", node)</span>
        }
}

// evalProgram ã¯ãƒ—ãƒ­ã‚°ãƒ©ãƒ å…¨ä½“ã‚’è©•ä¾¡ã™ã‚‹
func evalProgram(stmts []Statement, env *Environment) Object <span class="cov7" title="114">{
        var result Object

        for _, statement := range stmts </span><span class="cov7" title="130">{
                result = Eval(statement, env)

                switch result := result.(type) </span>{
                case *ReturnValue:<span class="cov3" title="5">
                        return result.Value</span>
                case *Error:<span class="cov4" title="14">
                        return result</span>
                }
        }

        <span class="cov7" title="95">return result</span>
}

// evalBlockStatement ã¯ãƒ–ãƒ­ãƒƒã‚¯æ–‡ã‚’è©•ä¾¡ã™ã‚‹
func evalBlockStatement(block *BlockStatement, env *Environment) Object <span class="cov5" title="19">{
        var result Object

        for _, statement := range block.Statements </span><span class="cov5" title="19">{
                result = Eval(statement, env)

                if result != nil </span><span class="cov5" title="19">{
                        rt := result.Type()
                        if rt == RETURN_VALUE_OBJ || rt == ERROR_OBJ </span><span class="cov3" title="6">{
                                return result
                        }</span>
                }
        }

        <span class="cov4" title="13">return result</span>
}

// evalPrefixExpression ã¯å‰ç½®æ¼”ç®—å­å¼ã‚’è©•ä¾¡ã™ã‚‹
func evalPrefixExpression(operator string, right Object) Object <span class="cov5" title="20">{
        switch operator </span>{
        case "!":<span class="cov4" title="9">
                return evalBangOperatorExpression(right)</span>
        case "-":<span class="cov3" title="8">
                return evalMinusPrefixOperatorExpression(right)</span>
        case "+":<span class="cov2" title="3">
                return evalPlusPrefixOperatorExpression(right)</span>
        default:<span class="cov0" title="0">
                return newError("unknown operator: %s%s", operator, right.Type())</span>
        }
}

// evalBangOperatorExpression ã¯è«–ç†å¦å®šæ¼”ç®—å­ã‚’è©•ä¾¡ã™ã‚‹
func evalBangOperatorExpression(right Object) Object <span class="cov4" title="9">{
        switch right </span>{
        case TRUE_OBJ_INSTANCE:<span class="cov2" title="3">
                return FALSE_OBJ_INSTANCE</span>
        case FALSE_OBJ_INSTANCE:<span class="cov2" title="4">
                return TRUE_OBJ_INSTANCE</span>
        case NULL_OBJ_INSTANCE:<span class="cov0" title="0">
                return TRUE_OBJ_INSTANCE</span>
        default:<span class="cov1" title="2">
                return FALSE_OBJ_INSTANCE</span>
        }
}

// evalMinusPrefixOperatorExpression ã¯ãƒã‚¤ãƒŠã‚¹å‰ç½®æ¼”ç®—å­ã‚’è©•ä¾¡ã™ã‚‹
func evalMinusPrefixOperatorExpression(right Object) Object <span class="cov3" title="8">{
        switch right := right.(type) </span>{
        case *Integer:<span class="cov3" title="6">
                return &amp;Integer{Value: -right.Value}</span>
        case *Float:<span class="cov1" title="1">
                return &amp;Float{Value: -right.Value}</span>
        default:<span class="cov1" title="1">
                return newError("unknown operator: -%s", right.Type())</span>
        }
}

// evalPlusPrefixOperatorExpression ã¯ãƒ—ãƒ©ã‚¹å‰ç½®æ¼”ç®—å­ã‚’è©•ä¾¡ã™ã‚‹
func evalPlusPrefixOperatorExpression(right Object) Object <span class="cov2" title="3">{
        switch right := right.(type) </span>{
        case *Integer:<span class="cov1" title="2">
                return &amp;Integer{Value: +right.Value}</span>
        case *Float:<span class="cov1" title="1">
                return &amp;Float{Value: +right.Value}</span>
        default:<span class="cov0" title="0">
                return newError("unknown operator: +%s", right.Type())</span>
        }
}

// evalInfixExpression ã¯ä¸­ç½®æ¼”ç®—å­å¼ã‚’è©•ä¾¡ã™ã‚‹
func evalInfixExpression(operator string, left, right Object) Object <span class="cov7" title="106">{
        switch </span>{
        case left.Type() == INTEGER_OBJ &amp;&amp; right.Type() == INTEGER_OBJ:<span class="cov6" title="73">
                return evalIntegerInfixExpression(operator, left, right)</span>
        case left.Type() == FLOAT_OBJ &amp;&amp; right.Type() == FLOAT_OBJ:<span class="cov4" title="11">
                return evalFloatInfixExpression(operator, left, right)</span>
        case left.Type() == INTEGER_OBJ &amp;&amp; right.Type() == FLOAT_OBJ:<span class="cov1" title="2">
                leftFloat := &amp;Float{Value: float64(left.(*Integer).Value)}
                return evalFloatInfixExpression(operator, leftFloat, right)</span>
        case left.Type() == FLOAT_OBJ &amp;&amp; right.Type() == INTEGER_OBJ:<span class="cov1" title="2">
                rightFloat := &amp;Float{Value: float64(right.(*Integer).Value)}
                return evalFloatInfixExpression(operator, left, rightFloat)</span>
        case left.Type() == STRING_OBJ &amp;&amp; right.Type() == STRING_OBJ:<span class="cov2" title="3">
                return evalStringInfixExpression(operator, left, right)</span>
        case operator == "==":<span class="cov3" title="7">
                return nativeBoolToPugBoolean(left == right)</span>
        case operator == "!=":<span class="cov1" title="2">
                return nativeBoolToPugBoolean(left != right)</span>
        default:<span class="cov3" title="6">
                return newError("unknown operator: %s %s %s",
                        left.Type(), operator, right.Type())</span>
        }
}

// evalIntegerInfixExpression ã¯æ•´æ•°åŒå£«ã®ä¸­ç½®æ¼”ç®—å­ã‚’è©•ä¾¡ã™ã‚‹
func evalIntegerInfixExpression(operator string, left, right Object) Object <span class="cov6" title="73">{
        leftVal := left.(*Integer).Value
        rightVal := right.(*Integer).Value

        switch operator </span>{
        case "+":<span class="cov5" title="22">
                return &amp;Integer{Value: leftVal + rightVal}</span>
        case "-":<span class="cov1" title="1">
                return &amp;Integer{Value: leftVal - rightVal}</span>
        case "*":<span class="cov5" title="19">
                return &amp;Integer{Value: leftVal * rightVal}</span>
        case "/":<span class="cov2" title="3">
                if rightVal == 0 </span><span class="cov1" title="1">{
                        return newError("division by zero")
                }</span>
                <span class="cov1" title="2">return &amp;Integer{Value: leftVal / rightVal}</span>
        case "%":<span class="cov2" title="3">
                if rightVal == 0 </span><span class="cov1" title="1">{
                        return newError("modulo by zero")
                }</span>
                <span class="cov1" title="2">return &amp;Integer{Value: leftVal % rightVal}</span>
        case "&lt;":<span class="cov3" title="6">
                return nativeBoolToPugBoolean(leftVal &lt; rightVal)</span>
        case "&gt;":<span class="cov4" title="11">
                return nativeBoolToPugBoolean(leftVal &gt; rightVal)</span>
        case "&lt;=":<span class="cov1" title="2">
                return nativeBoolToPugBoolean(leftVal &lt;= rightVal)</span>
        case "&gt;=":<span class="cov1" title="2">
                return nativeBoolToPugBoolean(leftVal &gt;= rightVal)</span>
        case "==":<span class="cov1" title="2">
                return nativeBoolToPugBoolean(leftVal == rightVal)</span>
        case "!=":<span class="cov1" title="2">
                return nativeBoolToPugBoolean(leftVal != rightVal)</span>
        default:<span class="cov0" title="0">
                return newError("unknown operator: %s", operator)</span>
        }
}

// evalFloatInfixExpression ã¯æµ®å‹•å°æ•°ç‚¹åŒå£«ã®ä¸­ç½®æ¼”ç®—å­ã‚’è©•ä¾¡ã™ã‚‹
func evalFloatInfixExpression(operator string, left, right Object) Object <span class="cov4" title="15">{
        leftVal := left.(*Float).Value
        rightVal := right.(*Float).Value

        switch operator </span>{
        case "+":<span class="cov2" title="3">
                return &amp;Float{Value: leftVal + rightVal}</span>
        case "-":<span class="cov1" title="1">
                return &amp;Float{Value: leftVal - rightVal}</span>
        case "*":<span class="cov2" title="3">
                return &amp;Float{Value: leftVal * rightVal}</span>
        case "/":<span class="cov1" title="2">
                if rightVal == 0.0 </span><span class="cov1" title="1">{
                        return newError("division by zero")
                }</span>
                <span class="cov1" title="1">return &amp;Float{Value: leftVal / rightVal}</span>
        case "&lt;":<span class="cov1" title="1">
                return nativeBoolToPugBoolean(leftVal &lt; rightVal)</span>
        case "&gt;":<span class="cov1" title="1">
                return nativeBoolToPugBoolean(leftVal &gt; rightVal)</span>
        case "&lt;=":<span class="cov1" title="1">
                return nativeBoolToPugBoolean(leftVal &lt;= rightVal)</span>
        case "&gt;=":<span class="cov1" title="1">
                return nativeBoolToPugBoolean(leftVal &gt;= rightVal)</span>
        case "==":<span class="cov1" title="1">
                return nativeBoolToPugBoolean(leftVal == rightVal)</span>
        case "!=":<span class="cov1" title="1">
                return nativeBoolToPugBoolean(leftVal != rightVal)</span>
        default:<span class="cov0" title="0">
                return newError("unknown operator: %s", operator)</span>
        }
}

// evalStringInfixExpression ã¯æ–‡å­—åˆ—åŒå£«ã®ä¸­ç½®æ¼”ç®—å­ã‚’è©•ä¾¡ã™ã‚‹
func evalStringInfixExpression(operator string, left, right Object) Object <span class="cov2" title="3">{
        leftVal := left.(*String).Value
        rightVal := right.(*String).Value

        switch operator </span>{
        case "+":<span class="cov1" title="2">
                return &amp;String{Value: leftVal + rightVal}</span>
        case "==":<span class="cov0" title="0">
                return nativeBoolToPugBoolean(leftVal == rightVal)</span>
        case "!=":<span class="cov0" title="0">
                return nativeBoolToPugBoolean(leftVal != rightVal)</span>
        default:<span class="cov1" title="1">
                return newError("unknown operator: %s %s %s",
                        left.Type(), operator, right.Type())</span>
        }
}

// evalIfExpression ã¯ifå¼ã‚’è©•ä¾¡ã™ã‚‹
func evalIfExpression(ie *IfExpression, env *Environment) Object <span class="cov4" title="12">{
        condition := Eval(ie.Condition, env)
        if isError(condition) </span><span class="cov0" title="0">{
                return condition
        }</span>

        <span class="cov4" title="12">if isTruthy(condition) </span><span class="cov4" title="9">{
                return Eval(ie.Consequence, env)
        }</span> else<span class="cov2" title="3"> if ie.Alternative != nil </span><span class="cov1" title="1">{
                return Eval(ie.Alternative, env)
        }</span> else<span class="cov1" title="2"> {
                return NULL_OBJ_INSTANCE
        }</span>
}

// evalIdentifier ã¯è­˜åˆ¥å­ã‚’è©•ä¾¡ã™ã‚‹
func evalIdentifier(node *Identifier, env *Environment) Object <span class="cov6" title="39">{
        if val, ok := env.Get(node.Value); ok </span><span class="cov5" title="28">{
                return val
        }</span>

        <span class="cov4" title="11">if builtin, ok := builtins[node.Value]; ok </span><span class="cov4" title="10">{
                return builtin
        }</span>

        <span class="cov1" title="1">return newError("identifier not found: %s", node.Value)</span>
}

// evalExpressions ã¯å¼ã®ãƒªã‚¹ãƒˆã‚’è©•ä¾¡ã™ã‚‹
func evalExpressions(exps []Expression, env *Environment) []Object <span class="cov5" title="19">{
        var result []Object

        for _, e := range exps </span><span class="cov5" title="24">{
                evaluated := Eval(e, env)
                if isError(evaluated) </span><span class="cov0" title="0">{
                        return []Object{evaluated}
                }</span>
                <span class="cov5" title="24">result = append(result, evaluated)</span>
        }

        <span class="cov5" title="19">return result</span>
}

// applyFunction ã¯é–¢æ•°ã‚’é©ç”¨ã™ã‚‹
func applyFunction(fn Object, args []Object) Object <span class="cov5" title="19">{
        switch fn := fn.(type) </span>{
        case *Function:<span class="cov4" title="9">
                extendedEnv := extendFunctionEnv(fn, args)
                evaluated := Eval(fn.Body, extendedEnv)
                return unwrapReturnValue(evaluated)</span>
        case *Builtin:<span class="cov4" title="10">
                return fn.Fn(args...)</span>
        default:<span class="cov0" title="0">
                return newError("not a function: %T", fn)</span>
        }
}

// extendFunctionEnv ã¯é–¢æ•°ã®ç’°å¢ƒã‚’æ‹¡å¼µã™ã‚‹
func extendFunctionEnv(fn *Function, args []Object) *Environment <span class="cov4" title="9">{
        env := NewEnclosedEnvironment(fn.Env)

        for paramIdx, param := range fn.Parameters </span><span class="cov4" title="12">{
                env.Set(param.Value, args[paramIdx])
        }</span>

        <span class="cov4" title="9">return env</span>
}

// unwrapReturnValue ã¯ReturnValueã‚’ã‚¢ãƒ³ãƒ©ãƒƒãƒ—ã™ã‚‹
func unwrapReturnValue(obj Object) Object <span class="cov4" title="9">{
        if returnValue, ok := obj.(*ReturnValue); ok </span><span class="cov1" title="1">{
                return returnValue.Value
        }</span>
        <span class="cov3" title="8">return obj</span>
}

// isTruthy ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒçœŸå½å€¤ã¨ã—ã¦çœŸã‹ã©ã†ã‹ã‚’åˆ¤å®šã™ã‚‹
func isTruthy(obj Object) bool <span class="cov4" title="12">{
        switch obj </span>{
        case NULL_OBJ_INSTANCE:<span class="cov0" title="0">
                return false</span>
        case TRUE_OBJ_INSTANCE:<span class="cov3" title="8">
                return true</span>
        case FALSE_OBJ_INSTANCE:<span class="cov2" title="3">
                return false</span>
        default:<span class="cov1" title="1">
                return true</span>
        }
}

// isError ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒã‚¨ãƒ©ãƒ¼ã‹ã©ã†ã‹ã‚’åˆ¤å®šã™ã‚‹
func isError(obj Object) bool <span class="cov8" title="322">{
        if obj != nil </span><span class="cov8" title="322">{
                return obj.Type() == ERROR_OBJ
        }</span>
        <span class="cov0" title="0">return false</span>
}

// newError ã¯æ–°ã—ã„ã‚¨ãƒ©ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‚’ä½œæˆã™ã‚‹
func newError(format string, a ...interface{}) *Error <span class="cov4" title="14">{
        return &amp;Error{Message: fmt.Sprintf(format, a...)}
}</span>

// nativeBoolToPugBoolean ã¯Goã®boolã‚’Pugã®Booleanã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã«å¤‰æ›ã™ã‚‹
func nativeBoolToPugBoolean(input bool) *BooleanObj <span class="cov6" title="74">{
        if input </span><span class="cov6" title="47">{
                return TRUE_OBJ_INSTANCE
        }</span>
        <span class="cov5" title="27">return FALSE_OBJ_INSTANCE</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package phase1

// Lexer ã¯å­—å¥è§£æå™¨ã®æ§‹é€ ä½“
type Lexer struct {
        input        string // è§£æå¯¾è±¡ã®å…¥åŠ›æ–‡å­—åˆ—
        position     int    // ç¾åœ¨ã®æ–‡å­—ä½ç½®ï¼ˆcurrent charã‚’æŒ‡ã™ï¼‰
        readPosition int    // æ¬¡ã«èª­ã‚€æ–‡å­—ä½ç½®ï¼ˆcurrent charã®æ¬¡ï¼‰
        ch           byte   // ç¾åœ¨æ¤œæŸ»ä¸­ã®æ–‡å­—
        line         int    // ç¾åœ¨ã®è¡Œç•ªå·ï¼ˆã‚¨ãƒ©ãƒ¼å ±å‘Šç”¨ï¼‰
        column       int    // ç¾åœ¨ã®åˆ—ç•ªå·ï¼ˆã‚¨ãƒ©ãƒ¼å ±å‘Šç”¨ï¼‰
}

// New ã¯æ–°ã—ã„Lexerã‚’ä½œæˆã™ã‚‹
func New(input string) *Lexer <span class="cov6" title="225">{
        l := &amp;Lexer{
                input:  input,
                line:   1,
                column: 0,
        }
        l.readChar() // æœ€åˆã®æ–‡å­—ã‚’èª­ã¿è¾¼ã‚€
        return l
}</span>

// readChar ã¯æ¬¡ã®æ–‡å­—ã‚’èª­ã¿è¾¼ã¿ã€ç¾åœ¨ä½ç½®ã‚’é€²ã‚ã‚‹
func (l *Lexer) readChar() <span class="cov10" title="3787">{
        if l.readPosition &gt;= len(l.input) </span><span class="cov7" title="602">{
                l.ch = 0 // ASCII NULæ–‡å­—ï¼ˆEOFï¼‰
        }</span> else<span class="cov9" title="3185"> {
                l.ch = l.input[l.readPosition]
        }</span>

        // è¡Œãƒ»åˆ—ç•ªå·ã®æ›´æ–°
        <span class="cov10" title="3787">if l.ch == '\n' </span><span class="cov5" title="53">{
                l.line++
                l.column = 0
        }</span> else<span class="cov9" title="3734"> {
                l.column++
        }</span>

        <span class="cov10" title="3787">l.position = l.readPosition
        l.readPosition++</span>
}

// peekChar ã¯æ¬¡ã®æ–‡å­—ã‚’å…ˆèª­ã¿ã™ã‚‹ï¼ˆä½ç½®ã¯é€²ã‚ãªã„ï¼‰
func (l *Lexer) peekChar() byte <span class="cov6" title="203">{
        if l.readPosition &gt;= len(l.input) </span><span class="cov1" title="2">{
                return 0
        }</span>
        <span class="cov6" title="201">return l.input[l.readPosition]</span>
}

// skipWhitespace ã¯ç©ºç™½æ–‡å­—ã‚’ã‚¹ã‚­ãƒƒãƒ—ã™ã‚‹
func (l *Lexer) skipWhitespace() <span class="cov9" title="1655">{
        for l.ch == ' ' || l.ch == '\t' || l.ch == '\n' || l.ch == '\r' </span><span class="cov8" title="739">{
                l.readChar()
        }</span>
}

// skipComment ã¯è¡Œã‚³ãƒ¡ãƒ³ãƒˆï¼ˆ//ï¼‰ã‚’ã‚¹ã‚­ãƒƒãƒ—ã™ã‚‹
func (l *Lexer) skipComment() <span class="cov2" title="3">{
        if l.ch == '/' &amp;&amp; l.peekChar() == '/' </span><span class="cov2" title="3">{
                // è¡Œæœ«ã¾ã§èª­ã¿é£›ã°ã™
                for l.ch != '\n' &amp;&amp; l.ch != 0 </span><span class="cov5" title="90">{
                        l.readChar()
                }</span>
        }
}

// readIdentifier ã¯è­˜åˆ¥å­ã‚’èª­ã¿å–ã‚‹
func (l *Lexer) readIdentifier() string <span class="cov7" title="322">{
        position := l.position

        // æœ€åˆã®æ–‡å­—ã¯ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆã¾ãŸã¯ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢
        if isLetter(l.ch) </span><span class="cov7" title="322">{
                l.readChar()

                // 2æ–‡å­—ç›®ä»¥é™ã¯ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆã€æ•°å­—ã€ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢
                for isLetter(l.ch) || isDigit(l.ch) </span><span class="cov8" title="720">{
                        l.readChar()
                }</span>
        }

        <span class="cov7" title="322">return l.input[position:l.position]</span>
}

// readNumber ã¯æ•°å€¤ã‚’èª­ã¿å–ã‚‹ï¼ˆæ•´æ•°ãƒ»æµ®å‹•å°æ•°ç‚¹æ•°å¯¾å¿œï¼‰
func (l *Lexer) readNumber() (string, TokenType) <span class="cov7" title="305">{
        position := l.position
        tokenType := INT

        // æ•´æ•°éƒ¨åˆ†ã‚’èª­ã‚€
        for isDigit(l.ch) </span><span class="cov7" title="359">{
                l.readChar()
        }</span>

        // å°æ•°ç‚¹ãŒã‚ã‚‹å ´åˆã¯æµ®å‹•å°æ•°ç‚¹æ•°
        <span class="cov7" title="305">if l.ch == '.' &amp;&amp; isDigit(l.peekChar()) </span><span class="cov5" title="42">{
                tokenType = FLOAT
                l.readChar() // '.'ã‚’ã‚¹ã‚­ãƒƒãƒ—

                // å°æ•°éƒ¨åˆ†ã‚’èª­ã‚€
                for isDigit(l.ch) </span><span class="cov5" title="55">{
                        l.readChar()
                }</span>
        }

        <span class="cov7" title="305">return l.input[position:l.position], tokenType</span>
}

// readString ã¯æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã‚’èª­ã¿å–ã‚‹
func (l *Lexer) readString() string <span class="cov4" title="24">{
        result := ""

        for </span><span class="cov6" title="169">{
                l.readChar()
                if l.ch == '"' || l.ch == 0 </span><span class="cov4" title="24">{
                        break</span>
                }
                // ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã®å‡¦ç†
                <span class="cov6" title="145">if l.ch == '\\' </span><span class="cov2" title="3">{
                        l.readChar() // ãƒãƒƒã‚¯ã‚¹ãƒ©ãƒƒã‚·ãƒ¥ã‚’ã‚¹ã‚­ãƒƒãƒ—
                        if l.ch != 0 </span><span class="cov2" title="3">{
                                switch l.ch </span>{
                                case 'n':<span class="cov1" title="1">
                                        result += "\n"</span>
                                case 't':<span class="cov0" title="0">
                                        result += "\t"</span>
                                case 'r':<span class="cov0" title="0">
                                        result += "\r"</span>
                                case '\\':<span class="cov0" title="0">
                                        result += "\\"</span>
                                case '"':<span class="cov1" title="2">
                                        result += "\\\""</span>
                                default:<span class="cov0" title="0">
                                        // æœªå¯¾å¿œã®ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—ã‚·ãƒ¼ã‚±ãƒ³ã‚¹ã¯ãã®ã¾ã¾
                                        result += "\\" + string(l.ch)</span>
                                }
                        }
                } else<span class="cov6" title="142"> {
                        result += string(l.ch)
                }</span>
        }

        <span class="cov4" title="24">return result</span>
}

// isLetter ã¯æ–‡å­—ãŒã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆã¾ãŸã¯ã‚¢ãƒ³ãƒ€ãƒ¼ã‚¹ã‚³ã‚¢ã‹ãƒã‚§ãƒƒã‚¯ã™ã‚‹
func isLetter(ch byte) bool <span class="cov9" title="1994">{
        return 'a' &lt;= ch &amp;&amp; ch &lt;= 'z' || 'A' &lt;= ch &amp;&amp; ch &lt;= 'Z' || ch == '_'
}</span>

// isDigit ã¯æ–‡å­—ãŒæ•°å­—ã‹ãƒã‚§ãƒƒã‚¯ã™ã‚‹
func isDigit(ch byte) bool <span class="cov8" title="1437">{
        return '0' &lt;= ch &amp;&amp; ch &lt;= '9'
}</span>

// NextToken ã¯æ¬¡ã®ãƒˆãƒ¼ã‚¯ãƒ³ã‚’è§£æã—ã¦è¿”ã™
func (l *Lexer) NextToken() Token <span class="cov9" title="1652">{
        var tok Token

        // ç©ºç™½ã¨ã‚³ãƒ¡ãƒ³ãƒˆã‚’ã‚¹ã‚­ãƒƒãƒ—
        for </span><span class="cov9" title="1655">{
                l.skipWhitespace()

                // ã‚³ãƒ¡ãƒ³ãƒˆãƒã‚§ãƒƒã‚¯
                if l.ch == '/' &amp;&amp; l.peekChar() == '/' </span><span class="cov2" title="3">{
                        l.skipComment()
                        continue</span>
                }
                <span class="cov9" title="1652">break</span>
        }

        // ç¾åœ¨ä½ç½®ã‚’è¨˜éŒ²
        <span class="cov9" title="1652">tok.Line = l.line
        tok.Column = l.column
        tok.Position = l.position

        switch l.ch </span>{
        case '.':<span class="cov1" title="1">
                if l.peekChar() == '.' </span><span class="cov1" title="1">{
                        ch := l.ch
                        l.readChar()
                        tok.Type = IDENT
                        tok.Literal = string(ch) + string(l.ch)
                }</span> else<span class="cov0" title="0"> {
                        tok.Type = ILLEGAL
                        tok.Literal = string(l.ch)
                }</span>
        case '=':<span class="cov5" title="49">
                if l.peekChar() == '=' </span><span class="cov4" title="20">{
                        ch := l.ch
                        l.readChar()
                        tok.Type = EQ
                        tok.Literal = string(ch) + string(l.ch)
                }</span> else<span class="cov4" title="29"> {
                        tok.Type = ASSIGN
                        tok.Literal = string(l.ch)
                }</span>
        case '+':<span class="cov5" title="66">
                tok.Type = PLUS
                tok.Literal = string(l.ch)</span>
        case '-':<span class="cov4" title="23">
                if l.peekChar() == '&gt;' </span><span class="cov1" title="1">{
                        ch := l.ch
                        l.readChar()
                        tok.Type = ARROW
                        tok.Literal = string(ch) + string(l.ch)
                }</span> else<span class="cov4" title="22"> {
                        tok.Type = MINUS
                        tok.Literal = string(l.ch)
                }</span>
        case '*':<span class="cov5" title="43">
                tok.Type = MULTIPLY
                tok.Literal = string(l.ch)</span>
        case '/':<span class="cov3" title="13">
                tok.Type = DIVIDE
                tok.Literal = string(l.ch)</span>
        case '%':<span class="cov2" title="4">
                tok.Type = MODULO
                tok.Literal = string(l.ch)</span>
        case '!':<span class="cov4" title="26">
                if l.peekChar() == '=' </span><span class="cov3" title="10">{
                        ch := l.ch
                        l.readChar()
                        tok.Type = NOT_EQ
                        tok.Literal = string(ch) + string(l.ch)
                }</span> else<span class="cov4" title="16"> {
                        tok.Type = NOT
                        tok.Literal = string(l.ch)
                }</span>
        case '&lt;':<span class="cov4" title="19">
                if l.peekChar() == '=' </span><span class="cov2" title="3">{
                        ch := l.ch
                        l.readChar()
                        tok.Type = LTE
                        tok.Literal = string(ch) + string(l.ch)
                }</span> else<span class="cov4" title="16"> {
                        tok.Type = LT
                        tok.Literal = string(l.ch)
                }</span>
        case '&gt;':<span class="cov4" title="21">
                if l.peekChar() == '=' </span><span class="cov2" title="3">{
                        ch := l.ch
                        l.readChar()
                        tok.Type = GTE
                        tok.Literal = string(ch) + string(l.ch)
                }</span> else<span class="cov4" title="18"> {
                        tok.Type = GT
                        tok.Literal = string(l.ch)
                }</span>
        case '&amp;':<span class="cov1" title="1">
                if l.peekChar() == '&amp;' </span><span class="cov0" title="0">{
                        ch := l.ch
                        l.readChar()
                        tok.Type = AND
                        tok.Literal = string(ch) + string(l.ch)
                }</span> else<span class="cov1" title="1"> {
                        tok.Type = ILLEGAL
                        tok.Literal = string(l.ch)
                }</span>
        case '|':<span class="cov1" title="1">
                if l.peekChar() == '|' </span><span class="cov0" title="0">{
                        ch := l.ch
                        l.readChar()
                        tok.Type = OR
                        tok.Literal = string(ch) + string(l.ch)
                }</span> else<span class="cov1" title="1"> {
                        tok.Type = ILLEGAL
                        tok.Literal = string(l.ch)
                }</span>
        case ',':<span class="cov4" title="21">
                tok.Type = COMMA
                tok.Literal = string(l.ch)</span>
        case ';':<span class="cov6" title="116">
                tok.Type = SEMICOLON
                tok.Literal = string(l.ch)</span>
        case ':':<span class="cov2" title="5">
                tok.Type = COLON
                tok.Literal = string(l.ch)</span>
        case '(':<span class="cov5" title="69">
                tok.Type = LPAREN
                tok.Literal = string(l.ch)</span>
        case ')':<span class="cov5" title="69">
                tok.Type = RPAREN
                tok.Literal = string(l.ch)</span>
        case '{':<span class="cov4" title="36">
                tok.Type = LBRACE
                tok.Literal = string(l.ch)</span>
        case '}':<span class="cov4" title="36">
                tok.Type = RBRACE
                tok.Literal = string(l.ch)</span>
        case '[':<span class="cov1" title="1">
                tok.Type = LBRACKET
                tok.Literal = string(l.ch)</span>
        case ']':<span class="cov1" title="1">
                tok.Type = RBRACKET
                tok.Literal = string(l.ch)</span>
        case '"':<span class="cov4" title="24">
                tok.Type = STRING
                tok.Literal = l.readString()</span>
        case 0:<span class="cov7" title="377">
                tok.Type = EOF
                tok.Literal = ""</span>
        default:<span class="cov8" title="630">
                if isLetter(l.ch) </span><span class="cov7" title="322">{
                        tok.Literal = l.readIdentifier()
                        tok.Type = LookupIdent(tok.Literal)
                        return tok // readIdentifierã§æ—¢ã«ä½ç½®ãŒé€²ã‚“ã§ã„ã‚‹ãŸã‚
                }</span> else<span class="cov7" title="308"> if isDigit(l.ch) </span><span class="cov7" title="305">{
                        tok.Literal, tok.Type = l.readNumber()
                        return tok // readNumberã§æ—¢ã«ä½ç½®ãŒé€²ã‚“ã§ã„ã‚‹ãŸã‚
                }</span> else<span class="cov2" title="3"> {
                        tok.Type = ILLEGAL
                        tok.Literal = string(l.ch)
                }</span>
        }

        <span class="cov8" title="1025">l.readChar()
        return tok</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package phase1

import (
        "bytes"
        "fmt"
        "hash/fnv"
        "strings"
)

// ObjectType ã¯ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®å‹ã‚’è¡¨ã™
type ObjectType string

const (
        INTEGER_OBJ      = "INTEGER"
        FLOAT_OBJ        = "FLOAT"
        BOOLEAN_OBJ      = "BOOLEAN"
        STRING_OBJ       = "STRING"
        NULL_OBJ         = "NULL"
        RETURN_VALUE_OBJ = "RETURN_VALUE"
        ERROR_OBJ        = "ERROR"
        FUNCTION_OBJ     = "FUNCTION"
        BUILTIN_OBJ      = "BUILTIN"
        ARRAY_OBJ        = "ARRAY"
        HASH_OBJ         = "HASH"
)

// Object ã¯å…¨ã¦ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆãŒå®Ÿè£…ã™ã‚‹ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
type Object interface {
        Type() ObjectType
        Inspect() string
}

// Hashable ã¯ãƒãƒƒã‚·ãƒ¥å¯èƒ½ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹
type Hashable interface {
        HashKey() HashKey
}

// HashKey ã¯ãƒãƒƒã‚·ãƒ¥ã®ã‚­ãƒ¼ã‚’è¡¨ã™
type HashKey struct {
        Type  ObjectType
        Value uint64
}

// Integer ã¯æ•´æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
type Integer struct {
        Value int64
}

func (i *Integer) Type() ObjectType <span class="cov10" title="380">{ return INTEGER_OBJ }</span>
func (i *Integer) Inspect() string  <span class="cov0" title="0">{ return fmt.Sprintf("%d", i.Value) }</span>
func (i *Integer) HashKey() HashKey <span class="cov0" title="0">{
        // Convert int64 to uint64 using Go's well-defined conversion
        // #nosec G115 -- Go's int64 to uint64 conversion is well-defined and safe
        return HashKey{Type: i.Type(), Value: uint64(i.Value)}
}</span>

// Float ã¯æµ®å‹•å°æ•°ç‚¹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
type Float struct {
        Value float64
}

func (f *Float) Type() ObjectType <span class="cov7" title="76">{ return FLOAT_OBJ }</span>
func (f *Float) Inspect() string  <span class="cov0" title="0">{ return fmt.Sprintf("%g", f.Value) }</span>

// BooleanObj ã¯ãƒ–ãƒ¼ãƒ«å€¤ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
type BooleanObj struct {
        Value bool
}

func (b *BooleanObj) Type() ObjectType <span class="cov8" title="130">{ return BOOLEAN_OBJ }</span>
func (b *BooleanObj) Inspect() string  <span class="cov0" title="0">{ return fmt.Sprintf("%t", b.Value) }</span>
func (b *BooleanObj) HashKey() HashKey <span class="cov0" title="0">{
        var value uint64
        if b.Value </span><span class="cov0" title="0">{
                value = 1
        }</span> else<span class="cov0" title="0"> {
                value = 0
        }</span>
        <span class="cov0" title="0">return HashKey{Type: b.Type(), Value: value}</span>
}

// String ã¯æ–‡å­—åˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
type String struct {
        Value string
}

func (s *String) Type() ObjectType <span class="cov6" title="39">{ return STRING_OBJ }</span>
func (s *String) Inspect() string  <span class="cov2" title="2">{ return s.Value }</span>
func (s *String) HashKey() HashKey <span class="cov0" title="0">{
        h := fnv.New64a()
        _, _ = h.Write([]byte(s.Value)) // Hash.Write never returns an error
        return HashKey{Type: s.Type(), Value: h.Sum64()}
}</span>

// Null ã¯nullã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
type Null struct{}

func (n *Null) Type() ObjectType <span class="cov0" title="0">{ return NULL_OBJ }</span>
func (n *Null) Inspect() string  <span class="cov0" title="0">{ return "null" }</span>

// ReturnValue ã¯returnæ–‡ã®å€¤ã‚’ãƒ©ãƒƒãƒ—ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
type ReturnValue struct {
        Value Object
}

func (rv *ReturnValue) Type() ObjectType <span class="cov2" title="3">{ return RETURN_VALUE_OBJ }</span>
func (rv *ReturnValue) Inspect() string  <span class="cov0" title="0">{ return rv.Value.Inspect() }</span>

// Error ã¯ã‚¨ãƒ©ãƒ¼ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
type Error struct {
        Message string
}

func (e *Error) Type() ObjectType <span class="cov3" title="4">{ return ERROR_OBJ }</span>
func (e *Error) Inspect() string  <span class="cov0" title="0">{ return "ERROR: " + e.Message }</span>

// Function ã¯é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
type Function struct {
        Parameters []*Identifier
        Body       *BlockStatement
        Env        *Environment
}

func (f *Function) Type() ObjectType <span class="cov5" title="17">{ return FUNCTION_OBJ }</span>
func (f *Function) Inspect() string <span class="cov0" title="0">{
        var out bytes.Buffer
        params := []string{}
        for _, p := range f.Parameters </span><span class="cov0" title="0">{
                params = append(params, p.String())
        }</span>
        <span class="cov0" title="0">out.WriteString("fn")
        out.WriteString("(")
        out.WriteString(strings.Join(params, ", "))
        out.WriteString(") {\n")
        out.WriteString(f.Body.String())
        out.WriteString("\n}")
        return out.String()</span>
}

// BuiltinFunction ã¯çµ„ã¿è¾¼ã¿é–¢æ•°ã®å‹
type BuiltinFunction func(args ...Object) Object

// Builtin ã¯çµ„ã¿è¾¼ã¿é–¢æ•°ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
type Builtin struct {
        Fn BuiltinFunction
}

func (b *Builtin) Type() ObjectType <span class="cov4" title="10">{ return BUILTIN_OBJ }</span>
func (b *Builtin) Inspect() string  <span class="cov0" title="0">{ return "builtin function" }</span>

// Array ã¯é…åˆ—ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
type Array struct {
        Elements []Object
}

func (ao *Array) Type() ObjectType <span class="cov0" title="0">{ return ARRAY_OBJ }</span>
func (ao *Array) Inspect() string <span class="cov0" title="0">{
        var out bytes.Buffer
        elements := []string{}
        for _, e := range ao.Elements </span><span class="cov0" title="0">{
                elements = append(elements, e.Inspect())
        }</span>
        <span class="cov0" title="0">out.WriteString("[")
        out.WriteString(strings.Join(elements, ", "))
        out.WriteString("]")
        return out.String()</span>
}

// HashPair ã¯ãƒãƒƒã‚·ãƒ¥ã®ã‚­ãƒ¼ã¨å€¤ã®ãƒšã‚¢
type HashPair struct {
        Key   Object
        Value Object
}

// Hash ã¯ãƒãƒƒã‚·ãƒ¥ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
type Hash struct {
        Pairs map[HashKey]HashPair
}

func (h *Hash) Type() ObjectType <span class="cov0" title="0">{ return HASH_OBJ }</span>
func (h *Hash) Inspect() string <span class="cov0" title="0">{
        var out bytes.Buffer
        pairs := []string{}
        for _, pair := range h.Pairs </span><span class="cov0" title="0">{
                pairs = append(pairs, fmt.Sprintf("%s: %s",
                        pair.Key.Inspect(), pair.Value.Inspect()))
        }</span>
        <span class="cov0" title="0">out.WriteString("{")
        out.WriteString(strings.Join(pairs, ", "))
        out.WriteString("}")
        return out.String()</span>
}

// ã‚ˆãä½¿ç”¨ã•ã‚Œã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³
var (
        NULL_OBJ_INSTANCE  = &amp;Null{}
        TRUE_OBJ_INSTANCE  = &amp;BooleanObj{Value: true}
        FALSE_OBJ_INSTANCE = &amp;BooleanObj{Value: false}
)
</pre>
		
		<pre class="file" id="file9" style="display: none">package phase1

import (
        "fmt"
        "strconv"
)

// æ¼”ç®—å­ã®å„ªå…ˆé †ä½å®šæ•°
const (
        _ int = iota
        LOWEST
        EQUALS      // ==
        LESSGREATER // &gt; ã¾ãŸã¯ &lt;
        SUM         // +
        PRODUCT     // *
        PREFIX      // -X ã¾ãŸã¯ !X
        CALL        // myFunction(X)
)

// æ¼”ç®—å­ã®å„ªå…ˆé †ä½ãƒãƒƒãƒ—
var precedences = map[TokenType]int{
        EQ:       EQUALS,
        NOT_EQ:   EQUALS,
        LT:       LESSGREATER,
        GT:       LESSGREATER,
        LTE:      LESSGREATER,
        GTE:      LESSGREATER,
        PLUS:     SUM,
        MINUS:    SUM,
        DIVIDE:   PRODUCT,
        MULTIPLY: PRODUCT,
        MODULO:   PRODUCT,
        LPAREN:   CALL,
}

// å‰ç½®æ§‹æ–‡è§£æé–¢æ•°ã®å‹
type prefixParseFn func() Expression

// ä¸­ç½®æ§‹æ–‡è§£æé–¢æ•°ã®å‹
type infixParseFn func(Expression) Expression

// Parser ã¯æ§‹æ–‡è§£æå™¨ã‚’è¡¨ã™
type Parser struct {
        l *Lexer

        curToken  Token
        peekToken Token

        errors []string

        prefixParseFns map[TokenType]prefixParseFn
        infixParseFns  map[TokenType]infixParseFn
}

// New ã¯æ–°ã—ã„Parserã‚’ä½œæˆã™ã‚‹
func NewParser(l *Lexer) *Parser <span class="cov7" title="187">{
        p := &amp;Parser{
                l:      l,
                errors: []string{},
        }

        // å‰ç½®æ§‹æ–‡è§£æé–¢æ•°ã®ç™»éŒ²
        p.prefixParseFns = make(map[TokenType]prefixParseFn)
        p.registerPrefix(IDENT, p.parseIdentifier)
        p.registerPrefix(INT, p.parseIntegerLiteral)
        p.registerPrefix(FLOAT, p.parseFloatLiteral)
        p.registerPrefix(STRING, p.parseStringLiteral)
        p.registerPrefix(TRUE, p.parseBoolean)
        p.registerPrefix(FALSE, p.parseBoolean)
        p.registerPrefix(NOT, p.parsePrefixExpression)
        p.registerPrefix(MINUS, p.parsePrefixExpression)
        p.registerPrefix(PLUS, p.parsePrefixExpression)
        p.registerPrefix(LPAREN, p.parseGroupedExpression)
        p.registerPrefix(IF, p.parseIfExpression)
        p.registerPrefix(FN, p.parseFunctionLiteral)

        // ä¸­ç½®æ§‹æ–‡è§£æé–¢æ•°ã®ç™»éŒ²
        p.infixParseFns = make(map[TokenType]infixParseFn)
        p.registerInfix(PLUS, p.parseInfixExpression)
        p.registerInfix(MINUS, p.parseInfixExpression)
        p.registerInfix(DIVIDE, p.parseInfixExpression)
        p.registerInfix(MULTIPLY, p.parseInfixExpression)
        p.registerInfix(MODULO, p.parseInfixExpression)
        p.registerInfix(EQ, p.parseInfixExpression)
        p.registerInfix(NOT_EQ, p.parseInfixExpression)
        p.registerInfix(LT, p.parseInfixExpression)
        p.registerInfix(GT, p.parseInfixExpression)
        p.registerInfix(LTE, p.parseInfixExpression)
        p.registerInfix(GTE, p.parseInfixExpression)
        p.registerInfix(LPAREN, p.parseCallExpression)

        // 2ã¤ã®ãƒˆãƒ¼ã‚¯ãƒ³ã‚’èª­ã¿è¾¼ã‚“ã§curTokenã¨peekTokenã‚’è¨­å®š
        p.nextToken()
        p.nextToken()

        return p
}</span>

// registerPrefix ã¯å‰ç½®æ§‹æ–‡è§£æé–¢æ•°ã‚’ç™»éŒ²ã™ã‚‹
func (p *Parser) registerPrefix(tokenType TokenType, fn prefixParseFn) <span class="cov10" title="2244">{
        p.prefixParseFns[tokenType] = fn
}</span>

// registerInfix ã¯ä¸­ç½®æ§‹æ–‡è§£æé–¢æ•°ã‚’ç™»éŒ²ã™ã‚‹
func (p *Parser) registerInfix(tokenType TokenType, fn infixParseFn) <span class="cov10" title="2244">{
        p.infixParseFns[tokenType] = fn
}</span>

// nextToken ã¯ãƒˆãƒ¼ã‚¯ãƒ³ã‚’é€²ã‚ã‚‹
func (p *Parser) nextToken() <span class="cov9" title="1469">{
        p.curToken = p.peekToken
        p.peekToken = p.l.NextToken()
}</span>

// Errors ã¯ãƒ‘ãƒ¼ã‚µãƒ¼ã®ã‚¨ãƒ©ãƒ¼ã‚’è¿”ã™
func (p *Parser) Errors() []string <span class="cov6" title="73">{
        return p.errors
}</span>

// peekError ã¯peekTokenã®äºˆæœŸã—ãªã„å‹ã«å¯¾ã™ã‚‹ã‚¨ãƒ©ãƒ¼ã‚’è¿½åŠ ã™ã‚‹
func (p *Parser) peekError(t TokenType) <span class="cov0" title="0">{
        msg := fmt.Sprintf("expected next token to be %s, got %s instead",
                t, p.peekToken.Type)
        p.errors = append(p.errors, msg)
}</span>

// noPrefixParseFnError ã¯å‰ç½®æ§‹æ–‡è§£æé–¢æ•°ãŒè¦‹ã¤ã‹ã‚‰ãªã„å ´åˆã®ã‚¨ãƒ©ãƒ¼ã‚’è¿½åŠ ã™ã‚‹
func (p *Parser) noPrefixParseFnError(t TokenType) <span class="cov0" title="0">{
        msg := fmt.Sprintf("no prefix parse function for %s found", t)
        p.errors = append(p.errors, msg)
}</span>

// ParseProgram ã¯ãƒ—ãƒ­ã‚°ãƒ©ãƒ å…¨ä½“ã‚’è§£æã™ã‚‹
func (p *Parser) ParseProgram() *Program <span class="cov7" title="187">{
        program := &amp;Program{}
        program.Statements = []Statement{}

        for !p.curTokenIs(EOF) </span><span class="cov7" title="209">{
                stmt := p.parseStatement()
                program.Statements = append(program.Statements, stmt)
                p.nextToken()
        }</span>

        <span class="cov7" title="187">return program</span>
}

// parseStatement ã¯æ–‡ã‚’è§£æã™ã‚‹
func (p *Parser) parseStatement() Statement <span class="cov7" title="238">{
        switch p.curToken.Type </span>{
        case LET:<span class="cov4" title="19">
                return p.parseLetStatement()</span>
        case RETURN:<span class="cov3" title="10">
                return p.parseReturnStatement()</span>
        default:<span class="cov7" title="209">
                return p.parseExpressionStatement()</span>
        }
}

// parseLetStatement ã¯letæ–‡ã‚’è§£æã™ã‚‹
func (p *Parser) parseLetStatement() *LetStatement <span class="cov4" title="19">{
        stmt := &amp;LetStatement{Token: p.curToken}

        if !p.expectPeek(IDENT) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov4" title="19">stmt.Name = &amp;Identifier{Token: p.curToken, Value: p.curToken.Literal}

        if !p.expectPeek(ASSIGN) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov4" title="19">p.nextToken()

        stmt.Value = p.parseExpression(LOWEST)

        if p.peekTokenIs(SEMICOLON) </span><span class="cov4" title="19">{
                p.nextToken()
        }</span>

        <span class="cov4" title="19">return stmt</span>
}

// parseReturnStatement ã¯returnæ–‡ã‚’è§£æã™ã‚‹
func (p *Parser) parseReturnStatement() *ReturnStatement <span class="cov3" title="10">{
        stmt := &amp;ReturnStatement{Token: p.curToken}

        p.nextToken()

        stmt.ReturnValue = p.parseExpression(LOWEST)

        if p.peekTokenIs(SEMICOLON) </span><span class="cov3" title="10">{
                p.nextToken()
        }</span>

        <span class="cov3" title="10">return stmt</span>
}

// parseExpressionStatement ã¯å¼æ–‡ã‚’è§£æã™ã‚‹
func (p *Parser) parseExpressionStatement() *ExpressionStatement <span class="cov7" title="209">{
        stmt := &amp;ExpressionStatement{Token: p.curToken}

        stmt.Expression = p.parseExpression(LOWEST)

        if p.peekTokenIs(SEMICOLON) </span><span class="cov5" title="67">{
                p.nextToken()
        }</span>

        <span class="cov7" title="209">return stmt</span>
}

// parseExpression ã¯å¼ã‚’è§£æã™ã‚‹ï¼ˆPratt Parserï¼‰
func (p *Parser) parseExpression(precedence int) Expression <span class="cov8" title="527">{
        prefix := p.prefixParseFns[p.curToken.Type]
        if prefix == nil </span><span class="cov0" title="0">{
                p.noPrefixParseFnError(p.curToken.Type)
                return nil
        }</span>
        <span class="cov8" title="527">leftExp := prefix()

        for !p.peekTokenIs(SEMICOLON) &amp;&amp; precedence &lt; p.peekPrecedence() </span><span class="cov7" title="215">{
                infix := p.infixParseFns[p.peekToken.Type]
                if infix == nil </span><span class="cov0" title="0">{
                        return leftExp
                }</span>

                <span class="cov7" title="215">p.nextToken()

                leftExp = infix(leftExp)</span>
        }

        <span class="cov8" title="527">return leftExp</span>
}

// parseIdentifier ã¯è­˜åˆ¥å­ã‚’è§£æã™ã‚‹
func (p *Parser) parseIdentifier() Expression <span class="cov6" title="108">{
        return &amp;Identifier{Token: p.curToken, Value: p.curToken.Literal}
}</span>

// parseIntegerLiteral ã¯æ•´æ•°ãƒªãƒ†ãƒ©ãƒ«ã‚’è§£æã™ã‚‹
func (p *Parser) parseIntegerLiteral() Expression <span class="cov7" title="241">{
        lit := &amp;IntegerLiteral{Token: p.curToken}

        value, err := strconv.ParseInt(p.curToken.Literal, 0, 64)
        if err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("could not parse %q as integer", p.curToken.Literal)
                p.errors = append(p.errors, msg)
                return nil
        }</span>

        <span class="cov7" title="241">lit.Value = value
        return lit</span>
}

// parseFloatLiteral ã¯æµ®å‹•å°æ•°ç‚¹ãƒªãƒ†ãƒ©ãƒ«ã‚’è§£æã™ã‚‹
func (p *Parser) parseFloatLiteral() Expression <span class="cov5" title="37">{
        lit := &amp;FloatLiteral{Token: p.curToken}

        value, err := strconv.ParseFloat(p.curToken.Literal, 64)
        if err != nil </span><span class="cov0" title="0">{
                msg := fmt.Sprintf("could not parse %q as float", p.curToken.Literal)
                p.errors = append(p.errors, msg)
                return nil
        }</span>

        <span class="cov5" title="37">lit.Value = value
        return lit</span>
}

// parseStringLiteral ã¯æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«ã‚’è§£æã™ã‚‹
func (p *Parser) parseStringLiteral() Expression <span class="cov4" title="16">{
        return &amp;StringLiteral{Token: p.curToken, Value: p.curToken.Literal}
}</span>

// parseBoolean ã¯ãƒ–ãƒ¼ãƒ«å€¤ãƒªãƒ†ãƒ©ãƒ«ã‚’è§£æã™ã‚‹
func (p *Parser) parseBoolean() Expression <span class="cov5" title="51">{
        return &amp;Boolean{Token: p.curToken, Value: p.curTokenIs(TRUE)}
}</span>

// parsePrefixExpression ã¯å‰ç½®æ¼”ç®—å­å¼ã‚’è§£æã™ã‚‹
func (p *Parser) parsePrefixExpression() Expression <span class="cov5" title="33">{
        expression := &amp;PrefixExpression{
                Token:    p.curToken,
                Operator: p.curToken.Literal,
        }

        p.nextToken()

        expression.Right = p.parseExpression(PREFIX)

        return expression
}</span>

// parseInfixExpression ã¯ä¸­ç½®æ¼”ç®—å­å¼ã‚’è§£æã™ã‚‹
func (p *Parser) parseInfixExpression(left Expression) Expression <span class="cov7" title="191">{
        expression := &amp;InfixExpression{
                Token:    p.curToken,
                Left:     left,
                Operator: p.curToken.Literal,
        }

        precedence := p.curPrecedence()
        p.nextToken()
        expression.Right = p.parseExpression(precedence)

        return expression
}</span>

// parseGroupedExpression ã¯æ‹¬å¼§ã§å›²ã¾ã‚ŒãŸå¼ã‚’è§£æã™ã‚‹
func (p *Parser) parseGroupedExpression() Expression <span class="cov4" title="14">{
        p.nextToken()

        exp := p.parseExpression(LOWEST)

        if !p.expectPeek(RPAREN) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov4" title="14">return exp</span>
}

// parseIfExpression ã¯ifå¼ã‚’è§£æã™ã‚‹
func (p *Parser) parseIfExpression() Expression <span class="cov4" title="14">{
        expression := &amp;IfExpression{Token: p.curToken}

        if !p.expectPeek(LPAREN) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov4" title="14">p.nextToken()
        expression.Condition = p.parseExpression(LOWEST)

        if !p.expectPeek(RPAREN) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov4" title="14">if !p.expectPeek(LBRACE) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov4" title="14">expression.Consequence = p.parseBlockStatement()

        if p.peekTokenIs(ELSE) </span><span class="cov2" title="3">{
                p.nextToken()

                if !p.expectPeek(LBRACE) </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov2" title="3">expression.Alternative = p.parseBlockStatement()</span>
        }

        <span class="cov4" title="14">return expression</span>
}

// parseBlockStatement ã¯ãƒ–ãƒ­ãƒƒã‚¯æ–‡ã‚’è§£æã™ã‚‹
func (p *Parser) parseBlockStatement() *BlockStatement <span class="cov4" title="30">{
        block := &amp;BlockStatement{Token: p.curToken}
        block.Statements = []Statement{}

        p.nextToken()

        for !p.curTokenIs(RBRACE) &amp;&amp; !p.curTokenIs(EOF) </span><span class="cov4" title="29">{
                stmt := p.parseStatement()
                block.Statements = append(block.Statements, stmt)
                p.nextToken()
        }</span>

        <span class="cov4" title="30">return block</span>
}

// parseFunctionLiteral ã¯é–¢æ•°ãƒªãƒ†ãƒ©ãƒ«ã‚’è§£æã™ã‚‹
func (p *Parser) parseFunctionLiteral() Expression <span class="cov3" title="13">{
        lit := &amp;FunctionLiteral{Token: p.curToken}

        if !p.expectPeek(LPAREN) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov3" title="13">lit.Parameters = p.parseFunctionParameters()

        if !p.expectPeek(LBRACE) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov3" title="13">lit.Body = p.parseBlockStatement()

        return lit</span>
}

// parseFunctionParameters ã¯é–¢æ•°ã®ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’è§£æã™ã‚‹
func (p *Parser) parseFunctionParameters() []*Identifier <span class="cov3" title="13">{
        identifiers := []*Identifier{}

        if p.peekTokenIs(RPAREN) </span><span class="cov1" title="1">{
                p.nextToken()
                return identifiers
        }</span>

        <span class="cov3" title="12">p.nextToken()

        ident := &amp;Identifier{Token: p.curToken, Value: p.curToken.Literal}
        identifiers = append(identifiers, ident)

        for p.peekTokenIs(COMMA) </span><span class="cov2" title="5">{
                p.nextToken()
                p.nextToken()
                ident := &amp;Identifier{Token: p.curToken, Value: p.curToken.Literal}
                identifiers = append(identifiers, ident)
        }</span>

        <span class="cov3" title="12">if !p.expectPeek(RPAREN) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov3" title="12">return identifiers</span>
}

// parseCallExpression ã¯é–¢æ•°å‘¼ã³å‡ºã—å¼ã‚’è§£æã™ã‚‹
func (p *Parser) parseCallExpression(fn Expression) Expression <span class="cov4" title="24">{
        exp := &amp;CallExpression{Token: p.curToken, Function: fn}
        exp.Arguments = p.parseExpressionList(RPAREN)
        return exp
}</span>

// parseExpressionList ã¯å¼ã®ãƒªã‚¹ãƒˆã‚’è§£æã™ã‚‹
func (p *Parser) parseExpressionList(end TokenType) []Expression <span class="cov4" title="24">{
        args := []Expression{}

        if p.peekTokenIs(end) </span><span class="cov0" title="0">{
                p.nextToken()
                return args
        }</span>

        <span class="cov4" title="24">p.nextToken()
        args = append(args, p.parseExpression(LOWEST))

        for p.peekTokenIs(COMMA) </span><span class="cov3" title="13">{
                p.nextToken()
                p.nextToken()
                args = append(args, p.parseExpression(LOWEST))
        }</span>

        <span class="cov4" title="24">if !p.expectPeek(end) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov4" title="24">return args</span>
}

// ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ãƒ¡ã‚½ãƒƒãƒ‰

// curTokenIs ã¯ç¾åœ¨ã®ãƒˆãƒ¼ã‚¯ãƒ³ãŒæŒ‡å®šã•ã‚ŒãŸå‹ã‹ãƒã‚§ãƒƒã‚¯ã™ã‚‹
func (p *Parser) curTokenIs(t TokenType) bool <span class="cov8" title="535">{
        return p.curToken.Type == t
}</span>

// peekTokenIs ã¯æ¬¡ã®ãƒˆãƒ¼ã‚¯ãƒ³ãŒæŒ‡å®šã•ã‚ŒãŸå‹ã‹ãƒã‚§ãƒƒã‚¯ã™ã‚‹
func (p *Parser) peekTokenIs(t TokenType) bool <span class="cov9" title="1244">{
        return p.peekToken.Type == t
}</span>

// expectPeek ã¯æ¬¡ã®ãƒˆãƒ¼ã‚¯ãƒ³ãŒäºˆæœŸã•ã‚ŒãŸå‹ã‹ãƒã‚§ãƒƒã‚¯ã—ã€ãã®å ´åˆã¯é€²ã‚ã‚‹
func (p *Parser) expectPeek(t TokenType) bool <span class="cov6" title="159">{
        if p.peekTokenIs(t) </span><span class="cov6" title="159">{
                p.nextToken()
                return true
        }</span> else<span class="cov0" title="0"> {
                p.peekError(t)
                return false
        }</span>
}

// peekPrecedence ã¯æ¬¡ã®ãƒˆãƒ¼ã‚¯ãƒ³ã®å„ªå…ˆé †ä½ã‚’è¿”ã™
func (p *Parser) peekPrecedence() int <span class="cov8" title="604">{
        if p, ok := precedences[p.peekToken.Type]; ok </span><span class="cov7" title="258">{
                return p
        }</span>
        <span class="cov7" title="346">return LOWEST</span>
}

// curPrecedence ã¯ç¾åœ¨ã®ãƒˆãƒ¼ã‚¯ãƒ³ã®å„ªå…ˆé †ä½ã‚’è¿”ã™
func (p *Parser) curPrecedence() int <span class="cov7" title="191">{
        if p, ok := precedences[p.curToken.Type]; ok </span><span class="cov7" title="191">{
                return p
        }</span>
        <span class="cov0" title="0">return LOWEST</span>
}
</pre>
		
		<pre class="file" id="file10" style="display: none">package phase1

import (
        "bufio"
        "fmt"
        "io"
)

const PROMPT = "&gt;&gt; "

// Start ã¯REPLã‚’é–‹å§‹ã™ã‚‹
func Start(in io.Reader, out io.Writer) <span class="cov0" title="0">{
        scanner := bufio.NewScanner(in)
        env := NewEnvironment()

        for </span><span class="cov0" title="0">{
                fmt.Fprint(out, PROMPT)
                scanned := scanner.Scan()
                if !scanned </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">line := scanner.Text()
                l := New(line)
                p := NewParser(l)
                program := p.ParseProgram()

                if len(p.Errors()) != 0 </span><span class="cov0" title="0">{
                        printParserErrors(out, p.Errors())
                        continue</span>
                }

                <span class="cov0" title="0">evaluated := Eval(program, env)
                if evaluated != nil </span><span class="cov0" title="0">{
                        _, _ = io.WriteString(out, evaluated.Inspect())
                        _, _ = io.WriteString(out, "\n")
                }</span>
        }
}

func printParserErrors(out io.Writer, errors []string) <span class="cov0" title="0">{
        for _, msg := range errors </span><span class="cov0" title="0">{
                _, _ = io.WriteString(out, "\t"+msg+"\n")
        }</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">package phase1

// TokenType ã¯ãƒˆãƒ¼ã‚¯ãƒ³ã®ç¨®é¡ã‚’è¡¨ã™
type TokenType string

// Token ã¯ãƒ¬ã‚¯ã‚µãƒ¼ãŒç”Ÿæˆã™ã‚‹ãƒˆãƒ¼ã‚¯ãƒ³ã‚’è¡¨ã™
type Token struct {
        Type     TokenType
        Literal  string
        Line     int
        Column   int
        Position int
}

// ãƒˆãƒ¼ã‚¯ãƒ³ã‚¿ã‚¤ãƒ—ã®å®šæ•°å®šç¾©
const (
        // ç‰¹æ®Šãƒˆãƒ¼ã‚¯ãƒ³
        ILLEGAL TokenType = "ILLEGAL" // ä¸æ­£ãªæ–‡å­—
        EOF     TokenType = "EOF"     // ãƒ•ã‚¡ã‚¤ãƒ«çµ‚ç«¯

        // è­˜åˆ¥å­ã¨ãƒªãƒ†ãƒ©ãƒ«
        IDENT  TokenType = "IDENT"  // è­˜åˆ¥å­ï¼ˆå¤‰æ•°åã€é–¢æ•°åï¼‰
        INT    TokenType = "INT"    // æ•´æ•°ãƒªãƒ†ãƒ©ãƒ«
        FLOAT  TokenType = "FLOAT"  // æµ®å‹•å°æ•°ç‚¹ãƒªãƒ†ãƒ©ãƒ«
        STRING TokenType = "STRING" // æ–‡å­—åˆ—ãƒªãƒ†ãƒ©ãƒ«

        // æ¼”ç®—å­
        ASSIGN   TokenType = "=" // ä»£å…¥
        PLUS     TokenType = "+" // åŠ ç®—
        MINUS    TokenType = "-" // æ¸›ç®—
        MULTIPLY TokenType = "*" // ä¹—ç®—
        DIVIDE   TokenType = "/" // é™¤ç®—
        MODULO   TokenType = "%" // å‰°ä½™

        // æ¯”è¼ƒæ¼”ç®—å­
        EQ     TokenType = "==" // ç­‰ä¾¡
        NOT_EQ TokenType = "!=" // éç­‰ä¾¡
        LT     TokenType = "&lt;"  // å°ãªã‚Š
        GT     TokenType = "&gt;"  // å¤§ãªã‚Š
        LTE    TokenType = "&lt;=" // ä»¥ä¸‹
        GTE    TokenType = "&gt;=" // ä»¥ä¸Š

        // è«–ç†æ¼”ç®—å­
        AND TokenType = "&amp;&amp;" // è«–ç†ç©
        OR  TokenType = "||" // è«–ç†å’Œ
        NOT TokenType = "!"  // è«–ç†å¦å®š

        // åŒºåˆ‡ã‚Šæ–‡å­—
        COMMA     TokenType = ","  // ã‚«ãƒ³ãƒ
        SEMICOLON TokenType = ";"  // ã‚»ãƒŸã‚³ãƒ­ãƒ³
        COLON     TokenType = ":"  // ã‚³ãƒ­ãƒ³
        ARROW     TokenType = "-&gt;" // çŸ¢å°ï¼ˆé–¢æ•°æˆ»ã‚Šå€¤å‹ï¼‰

        // æ‹¬å¼§é¡
        LPAREN   TokenType = "(" // å·¦ä¸¸æ‹¬å¼§
        RPAREN   TokenType = ")" // å³ä¸¸æ‹¬å¼§
        LBRACE   TokenType = "{" // å·¦æ³¢æ‹¬å¼§
        RBRACE   TokenType = "}" // å³æ³¢æ‹¬å¼§
        LBRACKET TokenType = "[" // å·¦è§’æ‹¬å¼§
        RBRACKET TokenType = "]" // å³è§’æ‹¬å¼§

        // ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
        LET      TokenType = "LET"      // letæ–‡
        FN       TokenType = "FN"       // function
        IF       TokenType = "IF"       // ifæ–‡
        ELSE     TokenType = "ELSE"     // elseæ–‡
        RETURN   TokenType = "RETURN"   // returnæ–‡
        TRUE     TokenType = "TRUE"     // boolean true
        FALSE    TokenType = "FALSE"    // boolean false
        WHILE    TokenType = "WHILE"    // whileæ–‡
        FOR      TokenType = "FOR"      // foræ–‡
        BREAK    TokenType = "BREAK"    // breakæ–‡
        CONTINUE TokenType = "CONTINUE" // continueæ–‡

        // å‹ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰
        INT_TYPE    TokenType = "INT_TYPE"    // intå‹
        FLOAT_TYPE  TokenType = "FLOAT_TYPE"  // floatå‹
        STRING_TYPE TokenType = "STRING_TYPE" // stringå‹
        BOOL_TYPE   TokenType = "BOOL_TYPE"   // boolå‹
)

// keywords ã¯äºˆç´„èªã®ãƒãƒƒãƒ—
var keywords = map[string]TokenType{
        "let":      LET,
        "fn":       FN,
        "if":       IF,
        "else":     ELSE,
        "return":   RETURN,
        "true":     TRUE,
        "false":    FALSE,
        "while":    WHILE,
        "for":      FOR,
        "break":    BREAK,
        "continue": CONTINUE,
        "int":      INT_TYPE,
        "float":    FLOAT_TYPE,
        "string":   STRING_TYPE,
        "bool":     BOOL_TYPE,
}

// LookupIdent ã¯è­˜åˆ¥å­ãŒã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‹ã©ã†ã‹ã‚’ãƒã‚§ãƒƒã‚¯ã—ã€é©åˆ‡ãªTokenTypeã‚’è¿”ã™
func LookupIdent(ident string) TokenType <span class="cov10" title="322">{
        if tok, ok := keywords[ident]; ok </span><span class="cov8" title="153">{
                return tok
        }</span>
        <span class="cov8" title="169">return IDENT</span>
}

// String ã¯Tokenã®æ–‡å­—åˆ—è¡¨ç¾ã‚’è¿”ã™
func (t Token) String() string <span class="cov0" title="0">{
        return string(t.Type) + ":" + t.Literal
}</span>
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
