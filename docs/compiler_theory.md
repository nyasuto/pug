# ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ç†è«–ï¼šä½“ç³»çš„ãªç†è«–è§£èª¬

**ðŸ“š ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©æŠ€è¡“ã®ç†è«–çš„åŸºç›¤**

## ðŸŽ¯ ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ç†è«–ã®å…¨ä½“åƒ

ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ç†è«–ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªžã‚’æ©Ÿæ¢°èªžã«å¤‰æ›ã™ã‚‹æŠ€è¡“ã®ç†è«–çš„åŸºç›¤ã§ã™ã€‚pugãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã‚’é€šã˜ã¦ã€ä»¥ä¸‹ã®ç†è«–ã‚’æ®µéšŽçš„ã«å®Ÿè·µã—ã¾ã™ï¼š

1. **å½¢å¼è¨€èªžç†è«–** - è¨€èªžã®æ•°å­¦çš„åŸºç›¤
2. **å­—å¥è§£æžç†è«–** - æ­£è¦è¨€èªžã¨æœ‰é™ã‚ªãƒ¼ãƒˆãƒžãƒˆãƒ³
3. **æ§‹æ–‡è§£æžç†è«–** - æ–‡è„ˆè‡ªç”±æ–‡æ³•ã¨ãƒ—ãƒƒã‚·ãƒ¥ãƒ€ã‚¦ãƒ³ã‚ªãƒ¼ãƒˆãƒžãƒˆãƒ³
4. **æ„å‘³è§£æžç†è«–** - åž‹ç†è«–ã¨è¨˜å·è¡¨ç®¡ç†
5. **ã‚³ãƒ¼ãƒ‰ç”Ÿæˆç†è«–** - ä¸­é–“è¡¨ç¾ã¨æœ€é©åŒ–
6. **æœ€é©åŒ–ç†è«–** - ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼è§£æžã¨åˆ¶å¾¡ãƒ•ãƒ­ãƒ¼è§£æž

---

## ðŸ“– ç¬¬1ç« ï¼šå½¢å¼è¨€èªžç†è«–ã®åŸºç¤Ž

### è¨€èªžã®æ•°å­¦çš„å®šç¾©

ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªžã¯å½¢å¼çš„ã«ä»¥ä¸‹ã®ã‚ˆã†ã«å®šç¾©ã•ã‚Œã¾ã™ï¼š

**å®šç¾©1.1ï¼ˆè¨€èªžï¼‰**
ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆ Î£ ä¸Šã®è¨€èªž L ã¯ã€Î£* ã®éƒ¨åˆ†é›†åˆã§ã‚ã‚‹ã€‚

```
Î£ = {a, b, c, ..., z, 0, 1, ..., 9, +, -, *, /, ...}  // ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆ
Î£* = ã™ã¹ã¦ã®æœ‰é™æ–‡å­—åˆ—ã®é›†åˆ
L âŠ† Î£*  // è¨€èªžã¯æ–‡å­—åˆ—ã®é›†åˆ
```

**ä¾‹ï¼šdogãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªž**
```
L_dog = { "let x = 42;", "fn add(a, b) { a + b }", ... }
```

### ãƒãƒ§ãƒ ã‚¹ã‚­ãƒ¼éšŽå±¤

å½¢å¼è¨€èªžã¯ç”Ÿæˆèƒ½åŠ›ã«ã‚ˆã‚Š4ã¤ã®ã‚¯ãƒ©ã‚¹ã«åˆ†é¡žã•ã‚Œã¾ã™ï¼š

| ã‚¿ã‚¤ãƒ— | è¨€èªžã‚¯ãƒ©ã‚¹ | æ–‡æ³• | ã‚ªãƒ¼ãƒˆãƒžãƒˆãƒ³ | ä¾‹ |
|--------|-----------|------|-------------|-----|
| **Type 0** | å¥æ§‹é€ è¨€èªž | ç„¡åˆ¶é™æ–‡æ³• | ãƒãƒ¥ãƒ¼ãƒªãƒ³ã‚°ãƒžã‚·ãƒ³ | ä»»æ„ã®è¨ˆç®—å¯èƒ½è¨€èªž |
| **Type 1** | æ–‡è„ˆä¾å­˜è¨€èªž | æ–‡è„ˆä¾å­˜æ–‡æ³• | ç·šå½¢æœ‰ç•Œã‚ªãƒ¼ãƒˆãƒžãƒˆãƒ³ | {aâ¿bâ¿câ¿ \| nâ‰¥1} |
| **Type 2** | æ–‡è„ˆè‡ªç”±è¨€èªž | æ–‡è„ˆè‡ªç”±æ–‡æ³• | ãƒ—ãƒƒã‚·ãƒ¥ãƒ€ã‚¦ãƒ³ã‚ªãƒ¼ãƒˆãƒžãƒˆãƒ³ | {aâ¿bâ¿ \| nâ‰¥1} |
| **Type 3** | æ­£è¦è¨€èªž | æ­£è¦æ–‡æ³• | æœ‰é™ã‚ªãƒ¼ãƒˆãƒžãƒˆãƒ³ | {(ab)*} |

**ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°è¨€èªžã®ä½ç½®ã¥ã‘**
- **å­—å¥è§£æž**ï¼šType 3ï¼ˆæ­£è¦è¨€èªžï¼‰
- **æ§‹æ–‡è§£æž**ï¼šType 2ï¼ˆæ–‡è„ˆè‡ªç”±è¨€èªžï¼‰
- **æ„å‘³è§£æž**ï¼šType 1ã¾ãŸã¯Type 0ï¼ˆæ–‡è„ˆä¾å­˜ï¼‰

### pugã«ãŠã‘ã‚‹å¿œç”¨

```
å­—å¥è§£æžï¼šè­˜åˆ¥å­ = [a-zA-Z][a-zA-Z0-9]*     (æ­£è¦è¨€èªž)
æ§‹æ–‡è§£æžï¼šE â†’ E + E | E * E | (E) | id      (æ–‡è„ˆè‡ªç”±è¨€èªž)
æ„å‘³è§£æžï¼šå¤‰æ•°ã¯ä½¿ç”¨å‰ã«å®£è¨€ã•ã‚Œã‚‹ã“ã¨          (æ–‡è„ˆä¾å­˜)
```

---

## ðŸ” ç¬¬2ç« ï¼šå­—å¥è§£æžç†è«–

### æ­£è¦è¨€èªžã¨æœ‰é™ã‚ªãƒ¼ãƒˆãƒžãƒˆãƒ³

å­—å¥è§£æžã¯æ­£è¦è¨€èªžç†è«–ã«åŸºã¥ãã¾ã™ã€‚

**å®šç†2.1ï¼ˆã‚¯ãƒªãƒ¼ãƒã®å®šç†ï¼‰**
ä»¥ä¸‹ã¯åŒç­‰ã§ã‚ã‚‹ï¼š
1. æ­£è¦è¡¨ç¾ã§è¡¨ç¾å¯èƒ½
2. æœ‰é™ã‚ªãƒ¼ãƒˆãƒžãƒˆãƒ³ã§èªè­˜å¯èƒ½
3. æ­£è¦æ–‡æ³•ã§ç”Ÿæˆå¯èƒ½

### æœ‰é™ã‚ªãƒ¼ãƒˆãƒžãƒˆãƒ³ã®å®šç¾©

**å®šç¾©2.1ï¼ˆæ±ºå®šæ€§æœ‰é™ã‚ªãƒ¼ãƒˆãƒžãƒˆãƒ³ï¼šDFAï¼‰**
DFA M = (Q, Î£, Î´, qâ‚€, F) ã“ã“ã§ï¼š
- Qï¼šçŠ¶æ…‹ã®æœ‰é™é›†åˆ
- Î£ï¼šå…¥åŠ›ã‚¢ãƒ«ãƒ•ã‚¡ãƒ™ãƒƒãƒˆ
- Î´ï¼šQ Ã— Î£ â†’ Qï¼ˆé·ç§»é–¢æ•°ï¼‰
- qâ‚€ âˆˆ Qï¼šåˆæœŸçŠ¶æ…‹
- F âŠ† Qï¼šå—ç†çŠ¶æ…‹ã®é›†åˆ

**ä¾‹ï¼šæ•´æ•°ãƒªãƒ†ãƒ©ãƒ«ã‚’èªè­˜ã™ã‚‹DFA**
```
Q = {qâ‚€, qâ‚, qâ‚‚}
Î£ = {0, 1, 2, ..., 9, +, -}
Î´(qâ‚€, +) = qâ‚, Î´(qâ‚€, -) = qâ‚, Î´(qâ‚€, digit) = qâ‚‚
Î´(qâ‚, digit) = qâ‚‚
Î´(qâ‚‚, digit) = qâ‚‚
F = {qâ‚‚}
```

### éžæ±ºå®šæ€§æœ‰é™ã‚ªãƒ¼ãƒˆãƒžãƒˆãƒ³ï¼ˆNFAï¼‰

**å®šç¾©2.2ï¼ˆéžæ±ºå®šæ€§æœ‰é™ã‚ªãƒ¼ãƒˆãƒžãƒˆãƒ³ï¼šNFAï¼‰**
NFA M = (Q, Î£, Î´, qâ‚€, F) ã“ã“ã§ï¼š
- Î´ï¼šQ Ã— (Î£ âˆª {Îµ}) â†’ 2^Qï¼ˆéžæ±ºå®šçš„é·ç§»é–¢æ•°ï¼‰

**å®šç†2.2ï¼ˆã‚µãƒ–ã‚»ãƒƒãƒˆæ§‹æˆæ³•ï¼‰**
ä»»æ„ã®NFAã«å¯¾ã—ã¦ã€åŒç­‰ãªè¨€èªžã‚’èªè­˜ã™ã‚‹DFAãŒæ§‹æˆå¯èƒ½ã€‚

### Thompsonæ§‹æˆæ³•

æ­£è¦è¡¨ç¾ã‹ã‚‰NFAã‚’æ§‹æˆã™ã‚‹æ–¹æ³•ï¼š

1. **åŸºæœ¬è¦ç´ **ï¼ša â†’ NFA(a)
2. **é€£æŽ¥**ï¼šAB â†’ NFA(A)ã¨NFA(B)ã‚’Îµé·ç§»ã§æŽ¥ç¶š
3. **é¸æŠž**ï¼šA|B â†’ Îµé·ç§»ã§åˆ†å²ãƒ»åˆæµ
4. **ã‚¯ãƒªãƒ¼ãƒé–‰åŒ…**ï¼šA* â†’ Îµé·ç§»ã§ãƒ«ãƒ¼ãƒ—æ§‹æˆ

**pugã§ã®å®Ÿè£…ä¾‹**
```go
// è­˜åˆ¥å­ã®æ­£è¦è¡¨ç¾: [a-zA-Z][a-zA-Z0-9]*
func (l *Lexer) readIdentifier() string {
    position := l.position
    // æœ€åˆã®æ–‡å­—ã¯è‹±å­—ã®ã¿
    for isLetter(l.ch) {
        l.readChar()
    }
    // å¾Œç¶šæ–‡å­—ã¯è‹±æ•°å­—
    for isLetter(l.ch) || isDigit(l.ch) {
        l.readChar()
    }
    return l.input[position:l.position]
}
```

---

## ðŸŒ³ ç¬¬3ç« ï¼šæ§‹æ–‡è§£æžç†è«–

### æ–‡è„ˆè‡ªç”±æ–‡æ³•

**å®šç¾©3.1ï¼ˆæ–‡è„ˆè‡ªç”±æ–‡æ³•ï¼šCFGï¼‰**
CFG G = (N, T, P, S) ã“ã“ã§ï¼š
- Nï¼šéžçµ‚ç«¯è¨˜å·ã®æœ‰é™é›†åˆ
- Tï¼šçµ‚ç«¯è¨˜å·ã®æœ‰é™é›†åˆï¼ˆN âˆ© T = âˆ…ï¼‰
- Pï¼šN â†’ (N âˆª T)* ã®ç”Ÿæˆè¦å‰‡ã®æœ‰é™é›†åˆ
- S âˆˆ Nï¼šé–‹å§‹è¨˜å·

**ä¾‹ï¼šç®—è¡“å¼ã®æ–‡æ³•**
```
G = ({E, T, F}, {+, *, (, ), id}, P, E)
P: E â†’ E + T | T
   T â†’ T * F | F  
   F â†’ (E) | id
```

### å°Žå‡ºã¨æ§‹æ–‡æœ¨

**å®šç¾©3.2ï¼ˆå·¦ç«¯å°Žå‡ºï¼‰**
å„ã‚¹ãƒ†ãƒƒãƒ—ã§æœ€ã‚‚å·¦ã®éžçµ‚ç«¯è¨˜å·ã‚’æ›¸ãæ›ãˆã‚‹å°Žå‡ºã€‚

**ä¾‹ï¼šid + id * id ã®å·¦ç«¯å°Žå‡º**
```
E â‡’ E + T â‡’ T + T â‡’ F + T â‡’ id + T â‡’ id + T * F 
  â‡’ id + F * F â‡’ id + id * F â‡’ id + id * id
```

### æ›–æ˜§æ€§ã¨å„ªå…ˆé †ä½

**å®šç¾©3.3ï¼ˆæ›–æ˜§ãªæ–‡æ³•ï¼‰**
ã‚ã‚‹æ–‡å­—åˆ—ã«å¯¾ã—ã¦2ã¤ä»¥ä¸Šã®ç•°ãªã‚‹å·¦ç«¯å°Žå‡ºï¼ˆæ§‹æ–‡æœ¨ï¼‰ãŒå­˜åœ¨ã™ã‚‹æ–‡æ³•ã€‚

**å•é¡Œä¾‹**ï¼šE â†’ E + E | E * E | id
æ–‡å­—åˆ— "id + id * id" ã«å¯¾ã—ã¦è¤‡æ•°ã®æ§‹æ–‡æœ¨ãŒå­˜åœ¨ã€‚

**è§£æ±ºæ³•1ï¼šæ–‡æ³•ã®æ›¸ãæ›ãˆ**
```
E â†’ E + T | T        // + ã®å„ªå…ˆåº¦ã‚’ä½Žã
T â†’ T * F | F        // * ã®å„ªå…ˆåº¦ã‚’é«˜ã  
F â†’ (E) | id
```

**è§£æ±ºæ³•2ï¼šæ¼”ç®—å­å„ªå…ˆé †ä½æ³•**
```
å„ªå…ˆé †ä½ãƒ†ãƒ¼ãƒ–ãƒ«ï¼š
    |  +  *  (  )  id $
----+------------------
 +  |  >  <  <  >  <  >
 *  |  >  >  <  >  <  >
 (  |  <  <  <  =  <  
 )  |  >  >     >     >
id  |  >  >     >     >
 $  |  <  <  <        
```

### LLæ§‹æ–‡è§£æž

**å®šç¾©3.4ï¼ˆLL(k)æ–‡æ³•ï¼‰**
å·¦ã‹ã‚‰å³ã«èª­ã¿ã€å·¦ç«¯å°Žå‡ºã‚’è¡Œã„ã€kå€‹ã®å…ˆèª­ã¿ã§æ±ºå®šçš„ã«è§£æžå¯èƒ½ãªæ–‡æ³•ã€‚

**FIRSTé›†åˆã¨FOLLOWé›†åˆ**
```
FIRST(Î±) = { a | Î± â‡’* aÎ², a âˆˆ T } âˆª { Îµ | Î± â‡’* Îµ }
FOLLOW(A) = { a | S â‡’* Î±AaÎ², a âˆˆ T } âˆª { $ | S â‡’* Î±A }
```

**ä¾‹ï¼šE â†’ T E'ã®æ§‹æ–‡è§£æžè¡¨**
```
     +    *    (   )   id   $
E           Eâ†’TE'      Eâ†’TE'
E'  E'â†’+TE'      E'â†’Îµ   E'â†’Îµ
T           Tâ†’FT'      Tâ†’FT'
T'  T'â†’Îµ  T'â†’*FT' T'â†’Îµ T'â†’Îµ
F           Fâ†’(E)      Fâ†’id
```

### LRæ§‹æ–‡è§£æž

**å®šç¾©3.5ï¼ˆLR(k)æ–‡æ³•ï¼‰**
å·¦ã‹ã‚‰å³ã«èª­ã¿ã€å³ç«¯å°Žå‡ºã®é€†ã‚’è¡Œã„ã€kå€‹ã®å…ˆèª­ã¿ã§æ±ºå®šçš„ã«è§£æžå¯èƒ½ãªæ–‡æ³•ã€‚

**LRæ§‹æ–‡è§£æžã®åˆ©ç‚¹**
- LLæ–‡æ³•ã‚ˆã‚Šåºƒã„ã‚¯ãƒ©ã‚¹ã‚’æ‰±ãˆã‚‹
- å·¦å†å¸°ã‚’è¨±å¯
- ã‚¨ãƒ©ãƒ¼æ¤œå‡ºãŒæ—©ã„

**SLRæ§‹æ–‡è§£æžè¡¨ã®æ§‹æˆ**
1. LR(0)é …ç›®é›†åˆã®æ§‹æˆ
2. GOTOã¨CLOSUREé–¢æ•°ã®è¨ˆç®—
3. SHIFTã¨REDUCEã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã®æ±ºå®š

**pugã®Pratt Parser**
pugã¯æ¼”ç®—å­å„ªå…ˆé †ä½ã‚’æ˜Žç¤ºçš„ã«æ‰±ãˆã‚‹Pratt Parserã‚’æŽ¡ç”¨ï¼š

```go
type prefixParseFn func() ast.Expression
type infixParseFn func(ast.Expression) ast.Expression

// å„ªå…ˆé †ä½ã«åŸºã¥ãè§£æž
func (p *Parser) parseExpression(precedence int) ast.Expression {
    left := p.prefixParseFns[p.curToken.Type]()
    
    for precedence < p.peekPrecedence() {
        infix := p.infixParseFns[p.peekToken.Type]
        left = infix(left)
    }
    
    return left
}
```

---

## ðŸ”¤ ç¬¬4ç« ï¼šæ„å‘³è§£æžç†è«–

### åž‹ç†è«–ã®åŸºç¤Ž

**å®šç¾©4.1ï¼ˆåž‹ã‚·ã‚¹ãƒ†ãƒ ï¼‰**
åž‹ã‚·ã‚¹ãƒ†ãƒ ã¯ã€ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®éƒ¨åˆ†ã«åž‹ã‚’å‰²ã‚Šå½“ã¦ã€ã“ã‚Œã‚‰ã®åž‹ãŒä¸€è²«ã—ã¦ã„ã‚‹ã“ã¨ã‚’ç¢ºèªã™ã‚‹è¦å‰‡ã®é›†åˆã€‚

**åž‹ã®åˆ†é¡ž**
```
åŸºæœ¬åž‹ï¼ˆBase Typesï¼‰ï¼šint, bool, string
é–¢æ•°åž‹ï¼ˆFunction Typesï¼‰ï¼šTâ‚ â†’ Tâ‚‚
ç›´ç©åž‹ï¼ˆProduct Typesï¼‰ï¼šTâ‚ Ã— Tâ‚‚
ç›´å’Œåž‹ï¼ˆSum Typesï¼‰ï¼šTâ‚ + Tâ‚‚
å¤šæ…‹åž‹ï¼ˆPolymorphic Typesï¼‰ï¼šâˆ€Î±.T
```

### åž‹åˆ¤å®šè¦å‰‡

**åž‹åˆ¤å®šã®è¨˜æ³•**
```
Î“ âŠ¢ e : T
```
ç’°å¢ƒÎ“ã®ä¸‹ã§å¼eã¯åž‹Tã‚’æŒã¤

**åŸºæœ¬çš„ãªåž‹åˆ¤å®šè¦å‰‡**
```
[Var] Î“(x) = T
      -----------
      Î“ âŠ¢ x : T

[App] Î“ âŠ¢ eâ‚ : Tâ‚ â†’ Tâ‚‚    Î“ âŠ¢ eâ‚‚ : Tâ‚
      ----------------------------
      Î“ âŠ¢ eâ‚ eâ‚‚ : Tâ‚‚

[Abs] Î“, x : Tâ‚ âŠ¢ e : Tâ‚‚
      --------------------
      Î“ âŠ¢ Î»x.e : Tâ‚ â†’ Tâ‚‚
```

### åž‹æŽ¨è«–ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 

**Algorithm Wï¼ˆHindley-Milneråž‹æŽ¨è«–ï¼‰**
```
W(Î“, e) = (S, T) where:
  S: æœ€ã‚‚ä¸€èˆ¬çš„ãªå˜ä¸€åŒ–å­ï¼ˆsubstitutionï¼‰
  T: eã®åž‹
```

**ä¾‹ï¼šletå¤šæ…‹æ€§**
```
let id = Î»x.x in (id 3, id true)
```
1. `id`ã®åž‹ã‚’`âˆ€Î±.Î± â†’ Î±`ã¨æŽ¨è«–
2. ä½¿ç”¨ç®‡æ‰€ã§å…·ä½“åŒ–ï¼š`int â†’ int`, `bool â†’ bool`

### pugã®åž‹ã‚·ã‚¹ãƒ†ãƒ å®Ÿè£…

```go
type Type interface {
    String() string
}

type IntegerType struct{}
type BooleanType struct{}
type FunctionType struct {
    Parameters []Type
    ReturnType Type
}

func (tc *TypeChecker) checkExpression(expr ast.Expression) Type {
    switch e := expr.(type) {
    case *ast.IntegerLiteral:
        return &IntegerType{}
    case *ast.InfixExpression:
        leftType := tc.checkExpression(e.Left)
        rightType := tc.checkExpression(e.Right)
        return tc.checkInfixOperation(e.Operator, leftType, rightType)
    }
}
```

---

## ðŸ—ï¸ ç¬¬5ç« ï¼šä¸­é–“è¡¨ç¾ç†è«–

### ä¸­é–“è¡¨ç¾ã®å¿…è¦æ€§

**ãªãœä¸­é–“è¡¨ç¾ãŒå¿…è¦ã‹**
1. **ãƒ•ãƒ­ãƒ³ãƒˆã‚¨ãƒ³ãƒ‰ã¨ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰ã®åˆ†é›¢**
2. **æœ€é©åŒ–ã®å…±é€šåŸºç›¤**
3. **è¤‡æ•°ã‚¿ãƒ¼ã‚²ãƒƒãƒˆã¸ã®å¯¾å¿œ**
4. **è§£æžã®ç°¡ç´ åŒ–**

### ä¸‰ç•ªåœ°ã‚³ãƒ¼ãƒ‰ï¼ˆThree-Address Codeï¼‰

**å®šç¾©5.1ï¼ˆä¸‰ç•ªåœ°ã‚³ãƒ¼ãƒ‰ï¼‰**
å„å‘½ä»¤ãŒæœ€å¤§3ã¤ã®ã‚¢ãƒ‰ãƒ¬ã‚¹ã‚’æŒã¤ä¸­é–“è¡¨ç¾ï¼š
```
x = y op z    // äºŒé …æ¼”ç®—
x = op y      // å˜é …æ¼”ç®—
x = y         // ã‚³ãƒ”ãƒ¼
goto L        // ç„¡æ¡ä»¶ã‚¸ãƒ£ãƒ³ãƒ—
if x relop y goto L  // æ¡ä»¶åˆ†å²
```

**ä¾‹ï¼š(a + b) * (c + d)ã®ä¸‰ç•ªåœ°ã‚³ãƒ¼ãƒ‰**
```
t1 = a + b
t2 = c + d  
t3 = t1 * t2
```

### SSAå½¢å¼ï¼ˆStatic Single Assignmentï¼‰

**å®šç¾©5.2ï¼ˆSSAå½¢å¼ï¼‰**
å„å¤‰æ•°ãŒæ­£ç¢ºã«ä¸€åº¦ã ã‘å®šç¾©ã•ã‚Œã‚‹ä¸­é–“è¡¨ç¾ã€‚

**Ï†é–¢æ•°**
åˆ¶å¾¡ãƒ•ãƒ­ãƒ¼ã®åˆæµç‚¹ã§å€¤ã‚’é¸æŠžï¼š
```
if (condition) {
    x1 = a + b;
} else {
    x2 = c + d;
}
x3 = Ï†(x1, x2);  // åˆ¶å¾¡ãƒ•ãƒ­ãƒ¼ã«å¿œã˜ã¦x1ã¾ãŸã¯x2ã‚’é¸æŠž
```

**SSAã®åˆ©ç‚¹**
1. **def-useé–¢ä¿‚ã®æ˜Žç¢ºåŒ–**
2. **æœ€é©åŒ–ã®ç°¡ç´ åŒ–**
3. **ä¸¦è¡Œæ€§ã®è§£æž**
4. **ãƒ¬ã‚¸ã‚¹ã‚¿å‰²ã‚Šå½“ã¦ã®åŠ¹çŽ‡åŒ–**

### åˆ¶å¾¡ãƒ•ãƒ­ãƒ¼ã‚°ãƒ©ãƒ•ï¼ˆCFGï¼‰

**å®šç¾©5.3ï¼ˆåˆ¶å¾¡ãƒ•ãƒ­ãƒ¼ã‚°ãƒ©ãƒ•ï¼‰**
CFG = (V, E) where:
- Vï¼šåŸºæœ¬ãƒ–ãƒ­ãƒƒã‚¯ã®é›†åˆ
- Eï¼šåˆ¶å¾¡ãƒ•ãƒ­ãƒ¼ã‚¨ãƒƒã‚¸ã®é›†åˆ

**åŸºæœ¬ãƒ–ãƒ­ãƒƒã‚¯**
- æœ€åˆã®å‘½ä»¤ã‹ã‚‰æœ€å¾Œã®å‘½ä»¤ã¾ã§é †æ¬¡å®Ÿè¡Œ
- åˆ†å²ã®ãªã„ç›´ç·šçš„ãªå‘½ä»¤åˆ—
- ã‚¨ãƒ³ãƒˆãƒªã¯å…ˆé ­ã®ã¿ã€ã‚¨ã‚°ã‚¸ãƒƒãƒˆã¯æœ«å°¾ã®ã¿

**ä¾‹ï¼šifæ–‡ã®CFG**
```
    [entry]
       |
   [condition]
    /       \
[then]    [else]
    \       /
    [merge]
       |
     [exit]
```

---

## âš¡ ç¬¬6ç« ï¼šæœ€é©åŒ–ç†è«–

### ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼è§£æž

**å®šç¾©6.1ï¼ˆãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼è§£æžï¼‰**
ãƒ—ãƒ­ã‚°ãƒ©ãƒ ã®åˆ¶å¾¡ãƒ•ãƒ­ãƒ¼å…¨ä½“ã«ã‚ãŸã£ã¦æƒ…å ±ã‚’ä¼æ’­ã•ã›ã‚‹è§£æžæ‰‹æ³•ã€‚

**æ ¼å­ç†è«–ï¼ˆLattice Theoryï¼‰**
```
(L, âŠ‘)ï¼šåŠé †åºé›†åˆ
âŠ¥ï¼šæœ€å°å…ƒï¼ˆbottomï¼‰
âŠ¤ï¼šæœ€å¤§å…ƒï¼ˆtopï¼‰
âŠ”ï¼šä¸Šé™ï¼ˆjoinï¼‰
âŠ“ï¼šä¸‹é™ï¼ˆmeetï¼‰
```

**åˆ°é”å®šç¾©è§£æžï¼ˆReaching Definitionsï¼‰**
```
gen[B] = Bã§ç”Ÿæˆã•ã‚Œã‚‹å®šç¾©
kill[B] = Bã§å‰Šé™¤ã•ã‚Œã‚‹å®šç¾©
in[B] = â‹ƒ{out[P] | P âˆˆ pred(B)}
out[B] = gen[B] â‹ƒ (in[B] - kill[B])
```

**ç”Ÿå­˜å¤‰æ•°è§£æžï¼ˆLiveness Analysisï¼‰**
```
use[B] = Bã§ä½¿ç”¨ã•ã‚Œã‚‹å¤‰æ•°
def[B] = Bã§å®šç¾©ã•ã‚Œã‚‹å¤‰æ•°
out[B] = â‹ƒ{in[S] | S âˆˆ succ(B)}
in[B] = use[B] â‹ƒ (out[B] - def[B])
```

### æœ€é©åŒ–å¤‰æ›

**å®šæ•°ç•³ã¿è¾¼ã¿ï¼ˆConstant Foldingï¼‰**
```
x = 2 + 3  â†’  x = 5
```

**å®šæ•°ä¼æ’­ï¼ˆConstant Propagationï¼‰**
```
x = 5      â†’  x = 5
y = x + 3      y = 8
```

**ãƒ‡ãƒƒãƒ‰ã‚³ãƒ¼ãƒ‰é™¤åŽ»ï¼ˆDead Code Eliminationï¼‰**
```
x = a + b    â†’  x = a + b
y = c + d        z = x * 2
z = x * 2
```

**å…±é€šéƒ¨åˆ†å¼é™¤åŽ»ï¼ˆCommon Subexpression Eliminationï¼‰**
```
a = b + c    â†’  t = b + c
d = b + c        a = t
                 d = t
```

### ãƒ«ãƒ¼ãƒ—æœ€é©åŒ–

**è‡ªç„¶ãƒ«ãƒ¼ãƒ—ã®è­˜åˆ¥**
```
å®šç†ï¼šé€†ã‚¨ãƒƒã‚¸(t, h)ã«ã¤ã„ã¦ã€hãŒtã‚’æ”¯é…ã™ã‚‹ã¨ãã€
     (t, h)ã¯è‡ªç„¶ãƒ«ãƒ¼ãƒ—ã‚’å½¢æˆã™ã‚‹ã€‚
```

**ãƒ«ãƒ¼ãƒ—ä¸å¤‰å¼ç§»å‹•ï¼ˆLoop Invariant Code Motionï¼‰**
```
for (i = 0; i < n; i++) {
    x = a + b;      // ãƒ«ãƒ¼ãƒ—ä¸å¤‰
    array[i] = x;
}

â†“

x = a + b;          // ãƒ«ãƒ¼ãƒ—å¤–ã«ç§»å‹•
for (i = 0; i < n; i++) {
    array[i] = x;
}
```

**ãƒ«ãƒ¼ãƒ—ã‚¢ãƒ³ãƒ­ãƒ¼ãƒªãƒ³ã‚°ï¼ˆLoop Unrollingï¼‰**
```
for (i = 0; i < n; i++) {     for (i = 0; i < n; i += 4) {
    a[i] = b[i] + c[i];   â†’      a[i] = b[i] + c[i];
}                              a[i+1] = b[i+1] + c[i+1];
                               a[i+2] = b[i+2] + c[i+2];
                               a[i+3] = b[i+3] + c[i+3];
                           }
```

---

## ðŸŽ¯ ç¬¬7ç« ï¼šãƒ¬ã‚¸ã‚¹ã‚¿å‰²ã‚Šå½“ã¦ç†è«–

### ã‚°ãƒ©ãƒ•å½©è‰²æ³•

**å®šç¾©7.1ï¼ˆå¹²æ¸‰ã‚°ãƒ©ãƒ•ï¼‰**
å¤‰æ•°é–“ã®å¹²æ¸‰é–¢ä¿‚ã‚’è¡¨ç¾ã™ã‚‹ã‚°ãƒ©ãƒ• G = (V, E) where:
- Vï¼šå¤‰æ•°ã®é›†åˆ
- Eï¼šåŒæ™‚ã«ç”Ÿå­˜ã™ã‚‹å¤‰æ•°å¯¾ã®ã‚¨ãƒƒã‚¸

**å®šç†7.1ï¼ˆã‚°ãƒ©ãƒ•å½©è‰²ã¨ãƒ¬ã‚¸ã‚¹ã‚¿å‰²ã‚Šå½“ã¦ï¼‰**
kå€‹ã®ãƒ¬ã‚¸ã‚¹ã‚¿ã§ã®ãƒ¬ã‚¸ã‚¹ã‚¿å‰²ã‚Šå½“ã¦å•é¡Œã¯ã€å¹²æ¸‰ã‚°ãƒ©ãƒ•ã®kå½©è‰²å•é¡Œã¨ç­‰ä¾¡ã€‚

**Chaitinå½©è‰²ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ **
```
1. æ¬¡æ•°ãŒkæœªæº€ã®ãƒŽãƒ¼ãƒ‰ã‚’é™¤åŽ»ï¼ˆã‚¹ã‚¿ãƒƒã‚¯ã«ãƒ—ãƒƒã‚·ãƒ¥ï¼‰
2. ã‚°ãƒ©ãƒ•ãŒç©ºã«ãªã‚‹ã¾ã§ç¹°ã‚Šè¿”ã—
3. ã‚¹ã‚¿ãƒƒã‚¯ã‹ã‚‰ãƒãƒƒãƒ—ã—ãªãŒã‚‰å½©è‰²
4. å½©è‰²ä¸å¯èƒ½ãªå ´åˆã¯ã‚¹ãƒ”ãƒ«
```

**ã‚¹ãƒ”ãƒ«å‡¦ç†**
```
ãƒ¬ã‚¸ã‚¹ã‚¿ä¸è¶³ã®å¤‰æ•°ã‚’ãƒ¡ãƒ¢ãƒªã«é€€é¿ï¼š
load  temp, spill_var    // ãƒ¡ãƒ¢ãƒªã‹ã‚‰ãƒ­ãƒ¼ãƒ‰
...use temp...
store temp, spill_var    // ãƒ¡ãƒ¢ãƒªã«æ ¼ç´
```

### ç·šå½¢èµ°æŸ»ãƒ¬ã‚¸ã‚¹ã‚¿å‰²ã‚Šå½“ã¦

**Linear Scanã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ **
```
1. å…¨ã¦ã®ç”Ÿå­˜åŒºé–“ã‚’é–‹å§‹ç‚¹ã§ã‚½ãƒ¼ãƒˆ
2. å„åŒºé–“ã«ã¤ã„ã¦ï¼š
   - æœŸé™åˆ‡ã‚Œã®åŒºé–“ã‚’è§£æ”¾
   - åˆ©ç”¨å¯èƒ½ãƒ¬ã‚¸ã‚¹ã‚¿ãŒã‚ã‚Œã°å‰²ã‚Šå½“ã¦
   - ãªã‘ã‚Œã°ã‚¹ãƒ”ãƒ«
```

**æ™‚é–“è¨ˆç®—é‡**ï¼šO(n log n) vs Chaitinã® O(nÂ³)

---

## ðŸ›ï¸ ç¬¬8ç« ï¼šã‚³ãƒ¼ãƒ‰ç”Ÿæˆç†è«–

### å‘½ä»¤é¸æŠž

**å®šç¾©8.1ï¼ˆå‘½ä»¤é¸æŠžå•é¡Œï¼‰**
ä¸­é–“è¡¨ç¾ã®å„ãƒŽãƒ¼ãƒ‰ã«å¯¾ã—ã¦ã€åŒç­‰ã®æ„å‘³ã‚’æŒã¤æ©Ÿæ¢°èªžå‘½ä»¤åˆ—ã‚’é¸æŠžã™ã‚‹å•é¡Œã€‚

**Tree Pattern Matching**
```
ä¸­é–“è¡¨ç¾ï¼š    ADD(LOAD(addr1), LOAD(addr2))
å‘½ä»¤é¸æŠžï¼š    mov addr1, %rax
             add addr2, %rax
```

**å‹•çš„ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°æ³•**
```
cost[node] = min{cost[pattern] + Î£cost[child]}
```

### å‘½ä»¤ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°

**ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³æœ€é©åŒ–**
```
å‘½ä»¤ã®ä¾å­˜é–¢ä¿‚ã‚’è€ƒæ…®ã—ã¦ãƒ‘ã‚¤ãƒ—ãƒ©ã‚¤ãƒ³åŠ¹çŽ‡ã‚’æœ€å¤§åŒ–ï¼š

Before:             After:
add r1, r2, r3      add r1, r2, r3
add r4, r3, r5  â†’   add r6, r7, r8    // ä¸¦è¡Œå®Ÿè¡Œå¯èƒ½
add r6, r7, r8      add r4, r3, r5
```

**List Scheduling**
```
1. ä¾å­˜ã‚°ãƒ©ãƒ•ã‚’æ§‹ç¯‰
2. æº–å‚™å®Œäº†å‘½ä»¤ã‚’ãƒªã‚¹ãƒˆã«è¿½åŠ 
3. å„ªå…ˆåº¦ã«åŸºã¥ã„ã¦å‘½ä»¤ã‚’é¸æŠžãƒ»ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
4. å¾Œç¶šå‘½ä»¤ã‚’æº–å‚™å®Œäº†ãƒªã‚¹ãƒˆã«è¿½åŠ 
```

### ãƒªãƒ³ã‚¯æ™‚æœ€é©åŒ–ï¼ˆLTOï¼‰

**å…¨ä½“ãƒ—ãƒ­ã‚°ãƒ©ãƒ æœ€é©åŒ–**
```
- é–¢æ•°é–“ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³å±•é–‹
- æœªä½¿ç”¨é–¢æ•°ã®é™¤åŽ»
- å®šæ•°ä¼æ’­ã®å…¨ä½“é©ç”¨
- ãƒ‡ãƒƒãƒ‰ã‚³ãƒ¼ãƒ‰é™¤åŽ»ã®å…¨ä½“é©ç”¨
```

---

## ðŸš€ ç¬¬9ç« ï¼šé«˜åº¦ãªæœ€é©åŒ–ç†è«–

### ãƒã‚¤ãƒ³ã‚¿è§£æž

**å®šç¾©9.1ï¼ˆåˆ¥åè§£æžï¼‰**
ãƒ—ãƒ­ã‚°ãƒ©ãƒ ä¸­ã®ãƒã‚¤ãƒ³ã‚¿ãŒæŒ‡ã—ç¤ºã™å¯èƒ½æ€§ã®ã‚ã‚‹è¨˜æ†¶å ´æ‰€ã‚’æ±ºå®šã™ã‚‹è§£æžã€‚

**Andersenåž‹è§£æž**
```
åŒ…å«åˆ¶ç´„ã®é›†åˆã‚’è§£ãï¼š
*p = q  â†’  points-to(q) âŠ† points-to(*p)
p = &x  â†’  {x} âŠ† points-to(p)
```

### ä¸¦è¡Œæœ€é©åŒ–

**ä¾å­˜é–¢ä¿‚è§£æž**
```
ãƒ«ãƒ¼ãƒ—ã®ä¸¦è¡ŒåŒ–å¯èƒ½æ€§ã‚’åˆ¤å®šï¼š
for (i = 0; i < n; i++) {
    a[i] = a[i-1] + b[i];  // ä¾å­˜é–¢ä¿‚ã‚ã‚Šï¼ˆä¸¦è¡ŒåŒ–ä¸å¯ï¼‰
}

for (i = 0; i < n; i++) {
    a[i] = b[i] + c[i];    // ä¾å­˜é–¢ä¿‚ãªã—ï¼ˆä¸¦è¡ŒåŒ–å¯èƒ½ï¼‰
}
```

**è‡ªå‹•ãƒ™ã‚¯ãƒˆãƒ«åŒ–**
```
ã‚¹ã‚«ãƒ©ãƒ¼ãƒ«ãƒ¼ãƒ—ã‚’SIMDå‘½ä»¤ã«å¤‰æ›ï¼š
for (i = 0; i < n; i++) {
    c[i] = a[i] + b[i];
}
â†“
vectorized add operations
```

### ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«èª˜å°Žæœ€é©åŒ–ï¼ˆPGOï¼‰

**å®Ÿè¡Œæ™‚æƒ…å ±ã®æ´»ç”¨**
```
1. ãƒ—ãƒ­ãƒ•ã‚¡ã‚¤ãƒ«æƒ…å ±åŽé›†
2. ãƒ›ãƒƒãƒˆãƒ‘ã‚¹ã®ç‰¹å®š
3. åˆ†å²äºˆæ¸¬æƒ…å ±ã®åˆ©ç”¨
4. é–¢æ•°ã®ã‚¤ãƒ³ãƒ©ã‚¤ãƒ³åˆ¤å®š
```

---

## ðŸ“Š ç¬¬10ç« ï¼šæ€§èƒ½è§£æžç†è«–

### è¨ˆç®—è¤‡é›‘åº¦ç†è«–

**å­—å¥è§£æž**ï¼šO(n) - ç·šå½¢æ™‚é–“
**æ§‹æ–‡è§£æž**ï¼š
- LL(1), LR(1): O(n)
- CYK: O(nÂ³)
- ä¸€èˆ¬CFG: O(nÂ³)

**æœ€é©åŒ–ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ **ï¼š
- ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼è§£æžï¼šO(nÂ³)
- ãƒ¬ã‚¸ã‚¹ã‚¿å‰²ã‚Šå½“ã¦ï¼šNPå®Œå…¨
- å‘½ä»¤ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒªãƒ³ã‚°ï¼šNPå®Œå…¨

### ã‚¢ãƒ ãƒ€ãƒ¼ãƒ«ã®æ³•å‰‡

**å®šç†10.1ï¼ˆAmdahl's Lawï¼‰**
```
é€Ÿåº¦å‘ä¸Šæ¯” = 1 / ((1 - P) + P/S)
P: ä¸¦è¡ŒåŒ–å¯èƒ½ãªéƒ¨åˆ†ã®å‰²åˆ
S: ä¸¦è¡Œéƒ¨åˆ†ã®é€Ÿåº¦å‘ä¸Šæ¯”
```

**ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©æœ€é©åŒ–ã¸ã®å¿œç”¨**
```
å…¨ä½“å®Ÿè¡Œæ™‚é–“ = æœ€é©åŒ–ä¸å¯èƒ½éƒ¨åˆ† + æœ€é©åŒ–éƒ¨åˆ†/æ”¹å–„çŽ‡
```

### æ€§èƒ½æ¸¬å®šç†è«–

**ãƒ™ãƒ³ãƒãƒžãƒ¼ã‚¯è¨­è¨ˆåŽŸå‰‡**
1. **ä»£è¡¨æ€§**ï¼šå®Ÿéš›ã®ãƒ¯ãƒ¼ã‚¯ãƒ­ãƒ¼ãƒ‰ã‚’åæ˜ 
2. **å†ç¾æ€§**ï¼šåŒä¸€æ¡ä»¶ã§åŒä¸€çµæžœ
3. **å…¬å¹³æ€§**ï¼šæ¯”è¼ƒå¯¾è±¡é–“ã§åŒç­‰ã®æ¡ä»¶
4. **çµ±è¨ˆçš„æœ‰æ„æ€§**ï¼šååˆ†ãªã‚µãƒ³ãƒ—ãƒ«æ•°

---

## ðŸŽ“ ç¬¬11ç« ï¼špugãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã§ã®ç†è«–å¿œç”¨

### Phase 1ã§ã®ç†è«–å¿œç”¨

**å­—å¥è§£æž**
- æ­£è¦è¡¨ç¾ â†’ NFA â†’ DFAå¤‰æ›
- Thompsonæ§‹æˆæ³•ã®å®Ÿè£…

**æ§‹æ–‡è§£æž**  
- Pratt Parserã«ã‚ˆã‚‹æ¼”ç®—å­å„ªå…ˆé †ä½
- å†å¸°ä¸‹é™æ³•ã®å®Ÿè£…

### Phase 2ã§ã®ç†è«–å¿œç”¨

**åž‹ã‚·ã‚¹ãƒ†ãƒ **
- å˜ç´”åž‹ä»˜ãÎ»è¨ˆç®—
- åž‹åˆ¤å®šè¦å‰‡ã®å®Ÿè£…

**ã‚³ãƒ¼ãƒ‰ç”Ÿæˆ**
- ä¸‰ç•ªåœ°ã‚³ãƒ¼ãƒ‰ã‹ã‚‰ã‚¢ã‚»ãƒ³ãƒ–ãƒªã¸ã®å¤‰æ›
- ãƒ¬ã‚¸ã‚¹ã‚¿ä½¿ç”¨ã®æœ€é©åŒ–

### Phase 3ã§ã®ç†è«–å¿œç”¨

**ä¸­é–“è¡¨ç¾**
- SSAå½¢å¼ã®æ§‹ç¯‰
- Ï†é–¢æ•°ã®é…ç½®

**ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼è§£æž**
- åˆ°é”å®šç¾©è§£æž
- ç”Ÿå­˜å¤‰æ•°è§£æž

### Phase 4ã§ã®ç†è«–å¿œç”¨

**LLVMçµ±åˆ**
- LLVM IRã®ç”Ÿæˆ
- é«˜åº¦æœ€é©åŒ–ãƒ‘ã‚¹ã®é©ç”¨

**ä¸¦è¡Œæœ€é©åŒ–**
- ä¾å­˜é–¢ä¿‚è§£æž
- è‡ªå‹•ä¸¦è¡ŒåŒ–

---

## ðŸ”¬ ç¬¬12ç« ï¼šå®Ÿè£…ã¨ç†è«–ã®å¯¾å¿œ

### ç†è«–ã®å®Ÿè£…ã§ã®ç°¡ç•¥åŒ–

**å®Ÿç”¨åŒ–ã§ã®å¦¥å”ç‚¹**
```
ç†è«–ï¼š        å®Ÿè£…ï¼š
å®Œå…¨ãªåž‹æŽ¨è«– â†’ æ˜Žç¤ºçš„åž‹æ³¨é‡ˆ
å®Œå…¨ãªæœ€é©åŒ– â†’ ãƒ’ãƒ¥ãƒ¼ãƒªã‚¹ãƒ†ã‚£ãƒƒã‚¯
åŽ³å¯†ãªè§£æž   â†’ è¿‘ä¼¼è§£æž
```

### ç†è«–ç ”ç©¶ã¨ç”£æ¥­å®Ÿè£…

**å­¦è¡“ç ”ç©¶ã®æˆæžœ**
- SSAå½¢å¼ï¼ˆ1991å¹´ï¼‰
- ã‚°ãƒ©ãƒ•å½©è‰²ãƒ¬ã‚¸ã‚¹ã‚¿å‰²ã‚Šå½“ã¦ï¼ˆ1981å¹´ï¼‰
- ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼è§£æžï¼ˆ1970å¹´ä»£ï¼‰

**ç”£æ¥­ã§ã®æŽ¡ç”¨**
- GCCï¼š2004å¹´ã«SSAæŽ¡ç”¨
- LLVMï¼šè¨­è¨ˆå½“åˆã‹ã‚‰SSA
- JIT ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ã§ã®æ´»ç”¨

---

## ðŸ“š ç¬¬13ç« ï¼šã•ã‚‰ãªã‚‹å­¦ç¿’ã®ãŸã‚ã«

### æŽ¨å¥¨æ•™ç§‘æ›¸

**åŸºç¤Žç†è«–**
1. **ã€ŒIntroduction to Automata Theory, Languages, and Computationã€** - Hopcroft, Motwani, Ullman
2. **ã€ŒFormal Language Theoryã€** - Salomaa

**ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ç†è«–**
1. **ã€ŒCompilers: Principles, Techniques, and Toolsã€** - Aho, Lam, Sethi, Ullman
2. **ã€ŒModern Compiler Implementationã€** - Appel
3. **ã€ŒEngineering a Compilerã€** - Cooper, Torczon

**æœ€é©åŒ–ç†è«–**
1. **ã€ŒOptimizing Compilers for Modern Architecturesã€** - Allen, Kennedy
2. **ã€ŒAdvanced Compiler Design and Implementationã€** - Muchnick

### ç ”ç©¶è«–æ–‡

**é‡è¦ãªè«–æ–‡**
1. **SSA Form** - Cytron et al. (1991)
2. **Graph Coloring Register Allocation** - Chaitin (1982)
3. **Linear Scan Register Allocation** - Poletto & Sarkar (1999)
4. **Profile-Guided Optimization** - Fisher (1981)

### ã‚ªãƒ³ãƒ©ã‚¤ãƒ³å­¦ç¿’ãƒªã‚½ãƒ¼ã‚¹

**è¬›ç¾©å‹•ç”»**
- MIT 6.035 Computer Language Engineering
- Stanford CS 143 Compilers  
- Berkeley CS 164 Programming Languages and Compilers

**å®Ÿè£…ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ**
- LLVM Tutorial
- TinyLang Compiler
- MiniJava Compiler

---

## ðŸŽ¯ ç†è§£åº¦ç¢ºèªå•é¡Œ

### åŸºç¤Žç†è«–

1. æ­£è¦è¨€èªžã¨æ–‡è„ˆè‡ªç”±è¨€èªžã®é•ã„ã‚’èª¬æ˜Žã›ã‚ˆ
2. LL(1)ã¨LR(1)ã®åˆ©ç‚¹ãƒ»æ¬ ç‚¹ã‚’æ¯”è¼ƒã›ã‚ˆ
3. SSAå½¢å¼ã®åˆ©ç‚¹ã‚’3ã¤æŒ™ã’ã‚ˆ

### å¿œç”¨ç†è«–

1. ãƒ‡ãƒ¼ã‚¿ãƒ•ãƒ­ãƒ¼è§£æžã®æ ¼å­ç†è«–ã«ã¤ã„ã¦èª¬æ˜Žã›ã‚ˆ
2. ã‚°ãƒ©ãƒ•å½©è‰²æ³•ã§ã®ã‚¹ãƒ”ãƒ«å‡¦ç†ã‚’èª¬æ˜Žã›ã‚ˆ
3. ã‚¢ãƒ ãƒ€ãƒ¼ãƒ«ã®æ³•å‰‡ã‚’ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©æœ€é©åŒ–ã«é©ç”¨ã›ã‚ˆ

### pugãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆ

1. pugã®Pratt Parserã®ç†è«–çš„åŸºç›¤ã¯ä½•ã‹
2. Phase 2ã®åž‹ã‚·ã‚¹ãƒ†ãƒ ã¯åž‹ç†è«–ã®ã©ã®éƒ¨åˆ†ã‚’å®Ÿè£…ã—ã¦ã„ã‚‹ã‹
3. äºˆå®šã•ã‚Œã¦ã„ã‚‹Phase 3ã®SSAå®Ÿè£…ã®ç†è«–çš„æ„ç¾©ã¯ä½•ã‹

---

**ðŸŽ‰ ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ç†è«–ã®å­¦ç¿’å®Œäº†ãŠã‚ã§ã¨ã†ã”ã–ã„ã¾ã™ï¼**

ã“ã®ç†è«–çš„åŸºç›¤ã‚’ç†è§£ã™ã‚‹ã“ã¨ã§ã€pugãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆã®å„å®Ÿè£…ãŒãªãœãã®ã‚ˆã†ã«è¨­è¨ˆã•ã‚Œã¦ã„ã‚‹ã‹ã€ãã—ã¦ç”£æ¥­ãƒ¬ãƒ™ãƒ«ã®ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©ãŒã©ã®ã‚ˆã†ãªç†è«–ã«åŸºã¥ã„ã¦ã„ã‚‹ã‹ãŒæ˜Žç¢ºã«ãªã‚Šã¾ã—ãŸã€‚ç†è«–ã¨å®Ÿè·µã®ä¸¡è¼ªã§ã€çœŸã«ç†è§£ã®æ·±ã„ã‚³ãƒ³ãƒ‘ã‚¤ãƒ©æŠ€è¡“è€…ã‚’ç›®æŒ‡ã—ã¾ã—ã‚‡ã†ï¼

**æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—ï¼šç†è«–ã‚’å®Ÿè·µã§ç¢ºèªã—ã€ã•ã‚‰ãªã‚‹é«˜åº¦ãªæœ€é©åŒ–æŠ€è¡“ã«æŒ‘æˆ¦ã—ã¾ã—ã‚‡ã†ï¼**